# CompanyAI - Modulbasierte Architektur Regeln
# Diese Regeln gelten ALLGEMEIN für ALLE Module (Backend und Frontend).
# Spezifische Beispiele dürfen niemals als Ausnahmen interpretiert werden –
# jede neue Modul-Implementation muss diese Standards vollständig erfüllen.

## Modulstruktur Standards

Befolge IMMER diese modulbasierte Ordnerstruktur für alle Module in `backend/src/modules/`:

### Pflicht-Struktur für jedes neue Modul:
```
backend/src/modules/[module-name]/
├── orchestrator.ts        # PFLICHT: API-Route-Handler und Koordination
├── types.ts              # PFLICHT: TypeScript-Interfaces und Typen
├── core/                 # OPTIONAL: Wiederverwendbare Hilfslogik
│   └── [helper-files].ts # z.B. auth.ts, utils.ts, validators.ts
└── functions/            # PFLICHT: Geschäftslogik-Funktionen
    ├── [function1].ts    # Eine Funktion pro Datei
    ├── [function2].ts    # Klare, beschreibende Namen
    └── [function3].ts    # Export von async functions
```

## Datei-Standards

### 1. types.ts - IMMER enthalten:
```typescript
// Input-Request-Typen
export interface Create[Entity]Request { ... }
export interface Update[Entity]Request { ... }
export interface Search[Entity]Request { ... }

// Entity-Typen
export interface [Entity] { 
  id: string;
  // weitere Properties
}

// Response-Typen
export interface APIResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
}

export interface PaginatedResponse<T> {
  data: T[];
  pagination: {
    total: number;
    page: number;
    limit: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
}
```

### 2. orchestrator.ts - IMMER enthalten:
```typescript
import { Request, Response } from 'express';
import { AuthenticatedRequest } from '../hr/core/auth'; // Zentrale Auth nutzen

export class [Module]Orchestrator {
  static async handle[Action](req: AuthenticatedRequest, res: Response) {
    // Handler-Implementation
  }
}

export function register[Module]Routes(router: any) {
  // Route-Registrierung
}
```

### 3. functions/[function].ts - Eine Funktion pro Datei:
```typescript
import { [Entity], [Request]Type, APIResponse } from '../types';

export async function [functionName](
  request: [Request]Type
): Promise<APIResponse<[Entity]>> {
  try {
    // Implementation
    return { success: true, data: result, message: 'Success' };
  } catch (error) {
    return { success: false, error: 'Error', message: 'Failed' };
  }
}
```

## Integration-Standards

### Neue Module MÜSSEN in backend/src/index.ts registriert werden:
1. Import hinzufügen: `import { register[Module]Routes } from './modules/[module]/orchestrator';`
2. Route registrieren: `register[Module]Routes(apiRouter);`
3. Module-Liste aktualisieren in health/hello endpoints
4. Dokumentation in availableModules ergänzen

### Authentifizierung - IMMER nutzen:
- Import: `import { AuthenticatedRequest, requireAuth, requirePermission } from '../hr/core/auth';`
- Für geschützte Routes: `requireAuth` oder `requirePermission(action, resource)`
- Logging: `logAuthEvent(userId, action, resource)`

## Naming Conventions

### Module-Namen:
- Kleinschreibung mit Bindestrichen: `hr`, `support`, `user-management`
- Beschreibende Namen, nicht zu allgemein

### API-Routen:
- RESTful: `/api/[module]/[entities]`
- Beispiele: `/api/hr/employees`, `/api/support/tickets`

### Funktions-Namen:
- Verben verwenden: `createEmployee`, `fetchTickets`, `generateReport`
- Async functions für alle Geschäftslogik
- Klare, beschreibende Namen

### Datei-Namen:
- camelCase für Functions: `createHRReport.ts`, `manageTickets.ts`
- Beschreibende Namen, die den Inhalt widerspiegeln

## Code-Standards

### Error Handling:
```typescript
try {
  // Implementation
  return { success: true, data: result, message: 'Success message' };
} catch (error) {
  console.error('Descriptive error message:', error);
  return {
    success: false,
    error: 'User-friendly error type',
    message: 'German error message for user'
  };
}
```

### Validation:
- Immer Request-Daten validieren
- Separate Validation-Funktionen erstellen
- Früh validieren, früh zurückgeben bei Fehlern

### Responses:
- IMMER APIResponse<T> Format verwenden
- Deutsche Fehlermeldungen für User
- Englische Fehler-Types für Logging
- Konsistente HTTP-Status-Codes

## PowerShell Kompatibilität
- Bevorzuge `;` statt `&&` in npm scripts
- Erstelle .ps1 Scripts für Module-spezifische Tasks
- Nutze PowerShell-freundliche Pfade

## Dokumentation Standards

### Markdown-Dokumentations-Policy (KRITISCH)
- Alle Dokumentations-Dateien mit Endung `.md` MÜSSEN unter `docs/` liegen.
- Erlaubte Ausnahmen:
  - `README.md` im Repository-Root (Projekt-Overview)
  - `frontend/README.md` und `backend/README.md` (nur falls unbedingt nötig; bevorzugt Inhalte in `docs/` konsolidieren)
- Nicht erlaubt:
  - Markdown-Dokumente außerhalb von `docs/` (z. B. Roadmaps, API-Beschreibungen, Architektur-Notizen) – diese müssen nach `docs/` verschoben werden.
- Vorgeschriebene Pfadkonventionen in `docs/`:
  - Globale Dokumente: `docs/README.md`, `docs/CHANGELOG.md`, `docs/DOCUMENTATION_OVERVIEW.md`, `docs/INTERDEPENDENCY.md`, `docs/IMPROVEMENTS_ROADMAP.md`
  - Modul-Dokumente: `docs/modules/[module]/README.md`, `docs/modules/[module]/API.md`, `docs/modules/[module]/CHANGELOG.md`
  - Architektur: `docs/architecture/overview.md`, `docs/architecture/module-guidelines.md`
- PR/Review-Regel: PRs mit `.md`-Dateien außerhalb von `docs/` (außer den oben genannten Ausnahmen) werden abgelehnt – Dateien müssen in die korrekte `docs/`-Struktur verschoben werden.
- Bei Verschiebungen von `.md` in `docs/` sind alle internen Links zu aktualisieren.

### PR/Review-Gates für DataSources/Integrations (KRITISCH)
- Jeder PR, der DataSources/Integrations ändert (z. B. neue Quelle, externe API, .env-Variablen, Sync-Mechanismen), MUSS folgende Dokumente aktualisieren – andernfalls wird der PR abgelehnt:
  - `docs/INTERDEPENDENCY.md` (DataSources-Dependencies, Environment-Dependencies, External-API-Dependencies, Sync-Dependencies, Cross-DataSource-Logic, Frontend-API-Bindings, Source-Typen manual/external)
  - `docs/DOCUMENTATION_OVERVIEW.md` (Integration-Architektur und Dokumentationsstruktur)
  - `docs/CHANGELOG.md` (versionierte Änderung an Integrationen)
  - Falls von einem Modul konsumiert: `docs/modules/[module]/README.md` (Nutzung/Abhängigkeiten) und `docs/modules/[module]/API.md` (genutzte Endpunkte, z. B. `/api/data/*`)
  - Falls AI/RAG betroffen: `docs/RAG_DATA_SOURCES.md` (Quelle, Umfang, PII-Richtlinien)
  - Falls Security/PII betroffen: `docs/AI_SECURITY_POLICY.md` (Scopes, Token-Flows, PII in Logs unterbinden)
  - Falls Logging-Flüsse betroffen: `docs/LOGGING_STRATEGY.md` (Events, reqId, Retention)

### PR/Review-Gates für Frontend Theme & Layout-Konfiguration (KRITISCH)
- Jede Änderung an Frontend-Theme-Parametern (z. B. Farben, Branding, Layout-Variablen) MUSS folgende Updates enthalten:
  - `frontend/.env` (oder entsprechende ENV-Datei) aktualisieren: Neue/angepasste `VITE_*` Variablen für Theme/Branding
  - `docs/INTERDEPENDENCY.md`: Abschnitt "Frontend-Theme/Branding" erweitern/aktualisieren (Environment-Dependencies, betroffene Komponenten wie `Header`, `Sidebar`, CSS-Variables)
  - `docs/DOCUMENTATION_OVERVIEW.md`: Dokumentationsstatus und ENV-Beispiel erweitern (Theme-Variablen auflisten)
  - `docs/CHANGELOG.md`: Versionierte UI/UX-Änderungen dokumentieren
  - Konsistenz prüfen: CSS-Custom-Properties (`--*`) in globalen Styles referenzieren; keine Hardcodes in Komponenten

### Jedes neue Modul MUSS dokumentiert werden (Pflicht)
```
docs/modules/[module-name]/
├── README.md           # Vollständige Modul-Dokumentation
├── API.md             # Detaillierte API-Dokumentation
└── CHANGELOG.md       # Versionierung und Änderungen
```

- Für JEDE Änderung an Endpunkten, Routen oder Strukturen des Moduls: `docs/modules/[module]/API.md` sofort aktualisieren (inkl. Request/Response-Beispiele, Statuscodes, Auth-Requirements)
- Für JEDE neue Funktion/Feature im Modul: `docs/modules/[module]/README.md` um Funktionsbeschreibung, Sicherheit, Abhängigkeiten und Limitierungen erweitern
- Für JEDE produktive Änderung: `docs/modules/[module]/CHANGELOG.md` um Version/Datum/Änderung ergänzen
- Globale Übersichten IMMER aktualisieren: `docs/DOCUMENTATION_OVERVIEW.md`, `docs/INTERDEPENDENCY.md`, `docs/CHANGELOG.md` (siehe Wartungspflichten)

## Dokumentations-Wartung (KRITISCH)

### Bei JEDER Änderung in docs/ - UPDATE PFLICHT:

#### 1. DOCUMENTATION_OVERVIEW.md aktualisieren:
```typescript
// Bei neuen Dokumenten in docs/:
// ✅ Dokumentationsstruktur-Tree erweitern
// ✅ Neue Datei in entsprechender Sektion beschreiben
// ✅ Umfang (Zeilen) und Abdeckung dokumentieren
// ✅ Wichtigkeit und Nutzung angeben

// Bei Änderungen an bestehenden Docs:
// ✅ Umfang (Zeilen) aktualisieren
// ✅ Abdeckung um neue Inhalte erweitern
// ✅ Status bei Fertigstellung anpassen
```

#### 2. INTERDEPENDENCY.md aktualisieren bei:
```typescript
// Backend-Änderungen:
// ✅ Neue Module → Backend-Module-Dependencies erweitern
// ✅ Neue Auth-Mechanismen → Authentifizierung-Sektion updaten
// ✅ Neue API-Patterns → API-Integration-Standards erweitern
// ✅ Neue orchestrator/types → Template-Referenzen aktualisieren

// Frontend-Änderungen:
// ✅ Neue Module → Frontend-Module-Dependencies erweitern
// ✅ Neue Layout-Komponenten → Layout-System-Sektion updaten
// ✅ Neue CSS-Klassen → CSS-Klassen-System erweitern
// ✅ Neue Router-Patterns → Router-Integration-Standards updaten

// DataSources/Integrations-Änderungen (KRITISCH):
// ✅ Neue DataSources → DataSources-Dependencies-Sektion erweitern
// ✅ .env Variablen → Environment-Dependencies dokumentieren
// ✅ Externe APIs (z. B. Microsoft Graph) → External-API-Dependencies hinzufügen
// ✅ Sync-Mechanismen → Sync-Dependencies dokumentieren (Trigger, Intervalle, Startbedingungen)
// ✅ Cross-DataSource Dependencies → Combined-Logic dokumentieren
// ✅ Frontend-DataSource-Bindings → Frontend-API-Dependencies updaten
// ✅ Source-Typen (manual/external) → Source-Type-Dependencies dokumentieren

// Shared Dependencies:
// ✅ Neue Auth-Logik → Kritische Abhängigkeiten erweitern
// ✅ Neue API-Calls → API-Pattern-Dokumentation updaten
// ✅ Breaking Changes → Breaking Change Prevention Liste erweitern
// ✅ Neue Integration-Guidelines hinzufügen
```

### AUTOMATISCHE DOKUMENTATIONS-UPDATES:

#### Bei neuen Backend-Modulen:
```bash
# PFLICHT-Updates:
1. ✅ docs/modules/[module]/README.md erstellen
2. ✅ docs/modules/[module]/API.md erstellen  
3. ✅ docs/modules/[module]/CHANGELOG.md erstellen
4. ✅ docs/DOCUMENTATION_OVERVIEW.md - Modul-Sektion hinzufügen
5. ✅ docs/INTERDEPENDENCY.md - Backend-Dependencies erweitern
6. ✅ docs/README.md - Module-Liste und Metriken aktualisieren
7. ✅ docs/CHANGELOG.md - Version und Features hinzufügen
```

#### Bei neuen Frontend-Modulen:
```bash
# PFLICHT-Updates:
1. ✅ docs/modules/[module]/README.md um Frontend-Sektion erweitern
2. ✅ docs/DOCUMENTATION_OVERVIEW.md - Frontend-Inhalte hinzufügen
3. ✅ docs/INTERDEPENDENCY.md - Frontend-Dependencies erweitern
4. ✅ docs/README.md - Frontend-Features aktualisieren
5. ✅ docs/CHANGELOG.md - UI/UX Änderungen dokumentieren
```

#### Bei neuen DataSources/Integrations (KRITISCH):
```bash
# SOFORT-Updates:
1. ✅ docs/INTERDEPENDENCY.md - DataSources-Dependencies-Sektion erweitern
2. ✅ docs/INTERDEPENDENCY.md - Environment-Variables (.env) dokumentieren
3. ✅ docs/INTERDEPENDENCY.md - External-API-Dependencies hinzufügen
4. ✅ docs/INTERDEPENDENCY.md - Frontend-API-Bindings dokumentieren
5. ✅ docs/DOCUMENTATION_OVERVIEW.md - Integration-Architektur erweitern
6. ✅ docs/CHANGELOG.md - Integration-Changes dokumentieren
7. ✅ docs/README.md - Neue Capabilities hinzufügen
```

#### Bei API-Änderungen:
```bash
# SOFORT-Updates:
1. ✅ docs/modules/[module]/API.md - Endpunkt-Dokumentation aktualisieren
2. ✅ docs/INTERDEPENDENCY.md - API-Integration-Standards anpassen
3. ✅ docs/modules/[module]/CHANGELOG.md - API-Changes dokumentieren
4. ✅ docs/CHANGELOG.md - Breaking Changes dokumentieren (falls vorhanden)
```

#### Bei Architektur-Änderungen:
```bash
# KRITISCHE Updates:
1. ✅ docs/INTERDEPENDENCY.md - Vollständige Dependency-Review
2. ✅ docs/architecture/overview.md - System-Architektur aktualisieren
3. ✅ docs/architecture/module-guidelines.md - Guidelines anpassen
4. ✅ docs/DOCUMENTATION_OVERVIEW.md - Architektur-Sektion updaten
5. ✅ .cursorrules - Standards bei Breaking Changes anpassen
```

### Dokumentations-Inhalte:
1. **README.md:**
   - Modul-Übersicht mit Zweck und Status
   - Implementierte Funktionen
   - Technische Implementation
   - Sicherheit & Berechtigungen
   - Performance-Metriken
   - Bekannte Limitierungen
   - Roadmap & Entwicklungsplan

2. **API.md:**
   - Alle API-Endpunkte dokumentiert
   - Request/Response-Beispiele
   - Error-Handling-Szenarien
   - PowerShell-Test-Beispiele
   - Authentifizierungs-Requirements

3. **CHANGELOG.md:**
   - Versionierte Änderungshistorie
   - Was hinzugefügt/geändert/entfernt wurde
   - Technische Details zu Updates
   - Geplante Verbesserungen

### Dokumentations-Updates:
- Bei JEDEM neuen Feature: Dokumentation aktualisieren
- Bei API-Änderungen: API.md sofort updaten
- Bei Breaking Changes: CHANGELOG.md ausführlich dokumentieren
- Haupt-README.md bei neuen Modulen erweitern

## Testing
- Test-Funktionen in orchestrator für jedes Modul
- PowerShell-Test-Scripts erstellen
- Mock-Daten für Entwicklung bereitstellen

## NICHT ERLAUBT:
❌ Module ohne orchestrator.ts
❌ Module ohne types.ts  
❌ Geschäftslogik direkt in orchestrator.ts
❌ Fehlende Error-Handling
❌ Untypisierte API-Responses
❌ Module ohne Authentifizierung
❌ Direkte Datenbankzugriffe ohne Abstraktionsschicht
❌ Module, die nicht in index.ts registriert sind
❌ Module ohne Dokumentation in docs/modules/
❌ API-Änderungen ohne Dokumentations-Update
❌ Neue Module ohne DOCUMENTATION_OVERVIEW.md Update
❌ Abhängigkeits-Änderungen ohne INTERDEPENDENCY.md Update
❌ Frontend-Module ohne Frontend-Dokumentation in bestehenden docs/modules/
❌ Neue Features ohne docs/CHANGELOG.md Eintrag
❌ Breaking Changes ohne ausführliche Dokumentation
❌ DataSources/Integrations ohne INTERDEPENDENCY.md Dependencies-Update
❌ .env Änderungen ohne Environment-Dependencies-Dokumentation
❌ Externe API-Integrationen ohne External-API-Dependencies-Dokumentation

## Module ↔ DataSources Consumption (KRITISCH)

Diese Regeln gelten für JEDES Modul, das Daten aus `backend/src/datasources/` liest oder schreibt.

### Grundsätze
- **Lesen:** Standard ist die kombinierte Quelle (entra + manual) via `entraac/combined.ts`.
  - Verwende ausschließlich zentrale Re-Exports: `import { getCombinedUsers, findCombinedUsers, getCombinedStats, createManualUser, updateManualUser, deleteManualUser } from '../../datasources';`
  - Kein direkter Zugriff auf externe APIs (z. B. Microsoft Graph) aus Modulen.
- **Schreiben:** Ausschließlich in die manuelle Quelle (`manual`). `entra` ist strikt read-only.
- **Mapping-Standard (Combined → Modul-Entity):**
  - `displayName` → `firstName`/`lastName`
  - `mail`/`userPrincipalName` → `email`
  - `jobTitle` → `position`
  - `department` → `department`
  - `accountEnabled` → `status` (active/inactive/pending)
- **Audit & Security:**
  - `logAuthEvent(userId, action, resource)` in Orchestrator-Handlern verwenden
  - `requireAuth`/`requirePermission` strikt einsetzen
  - Keine PII in Logs

### Pflichten bei Modul↔DataSources-Verknüpfung (PR/Review-Checklist)
1. Code-Integration
   - [ ] Nur zentrale Re-Exports aus `backend/src/datasources/index.ts` importiert
   - [ ] Lesezugriffe über `getCombinedUsers`/`findCombinedUsers`
   - [ ] Schreibzugriffe nur über `createManualUser`/`updateManualUser`/`deleteManualUser`
   - [ ] Einheitliches Mapping auf Modul-Entities implementiert
   - [ ] Vollständiges Error-Handling (engl. Error-Typ, dt. User-Message)
   - [ ] `createdBy`/`updatedBy` beim Schreiben gesetzt (wenn verfügbar)
2. Dokumentation (PFLICHT)
   - [ ] `docs/INTERDEPENDENCY.md`: Modul-spezifische Bindings ergänzt (lesen=combined, schreiben=manual, Stats, Mapping)
   - [ ] `docs/modules/[module]/README.md`: DataSources-Integration beschrieben
   - [ ] `docs/modules/[module]/API.md`: Endpunkt-Semantik (combined/manual) dokumentiert
   - [ ] `docs/CHANGELOG.md`: Unveröffentlicht → „Docs/Integrations“ Eintrag
   - [ ] `docs/DOCUMENTATION_OVERVIEW.md`: Umfang/Abdeckung aktualisiert
3. API/Contracts
   - [ ] Keine Breaking Changes ohne Changelog + Doc-Updates
   - [ ] Response-Typen im Modul `types.ts` konsistent mit Mapping
4. Tests
   - [ ] PowerShell-Tests für read (combined) und write (manual)
   - [ ] Error-Szenarien (Forbidden für `entra`-Writes) abgedeckt

### Nicht erlaubt (Hard-Fails)
- ❌ Direkte externe API-Calls (Graph) aus Modulen
- ❌ Schreiben in `entra`
- ❌ Umgehen der zentralen DataSources-Re-Exports
- ❌ Abweichende Mapping-Keys ohne Dokumentation/Types-Update
- ❌ Verknüpfungen ohne Doku-Updates gemäß Pflichtliste

## Bei JEDEM neuen Modul:
1. ✅ Ordnerstruktur nach Standard erstellen
2. ✅ types.ts mit allen nötigen Interfaces
3. ✅ functions/ mit separaten Funktionsdateien  
4. ✅ orchestrator.ts mit Route-Handlern
5. ✅ Integration in index.ts
6. ✅ Vollständige Dokumentation erstellen:
   - docs/modules/[module]/README.md
   - docs/modules/[module]/API.md
   - docs/modules/[module]/CHANGELOG.md
7. ✅ **KRITISCH: Dokumentations-Wartung**
   - docs/DOCUMENTATION_OVERVIEW.md erweitern
   - docs/INTERDEPENDENCY.md um Dependencies erweitern
   - docs/README.md Module-Liste aktualisieren
   - docs/CHANGELOG.md Version hinzufügen
8. ✅ Test-Script erweitern
9. ✅ Haupt-Dokumentation aktualisieren

## Bei JEDER neuen DataSource/Integration:
1. ✅ Ordnerstruktur in `backend/src/datasources/[source]/` erstellen
2. ✅ Types, Store, Client/Sync-Logik implementieren
3. ✅ API-Routes in `backend/src/app.ts` registrieren
4. ✅ .env Variablen hinzufügen und dokumentieren
5. ✅ **KRITISCH: INTERDEPENDENCY.md aktualisieren**
   - DataSources-Dependencies-Sektion erweitern
   - Environment-Variables (.env) dokumentieren
   - External-API-Dependencies hinzufügen
   - Frontend-API-Bindings dokumentieren
   - Cross-DataSource Dependencies dokumentieren
6. ✅ `docs/DOCUMENTATION_OVERVIEW.md` erweitern
7. ✅ `docs/CHANGELOG.md` aktualisieren
8. ✅ Frontend-Integration planen und dokumentieren

## Neue Module – Verbindliche Backend-/Frontend-Integration (KRITISCH)

### Backend (Pflicht)
- Ordner: `backend/src/modules/[module]/` mit Struktur gemäß Modulstandards (siehe oben)
- Routen-Registrierung: `register[Module]Routes(apiRouter)` in `backend/src/app.ts` hinzufügen
- Auth: `requireAuth`/`requirePermission` konsequent verwenden
- Health/Hello: Endpunkt-Liste in `/api/hello` um Modul ergänzen (Beschreibung + Endpunkte)
- Tests: Mindestens Health-/Routing-Test für neues Modul

### Frontend (Pflicht)
- Ordner: `frontend/src/modules/[module]/` mit:
  - `[Module]Module.tsx` (interner Router gemäß Standard)
  - `pages/` (mind. eine Page-Komponente)
  - `styles/[Module]Pages.css`
- Router: In `frontend/src/App.tsx` Route für das Modul registrieren:
  - `<Route path="/[module]/*" element={<MainLayout><[Module]Module /></MainLayout>} />` (mit `RequireAuth` Wrapper)
- Navigation (Pflicht): In `frontend/src/layouts/components/Sidebar.tsx` Navigations-Eintrag hinzufügen (inkl. Submenu, falls zutreffend)
- UI-Standards: Vorhandene CSS-Klassen verwenden (page-header, content-section, etc.)

### Page-Struktur je Modul (Pflicht)
- Für JEDES fachliche Feature im Modul MUSS eine eigene Page-Komponente angelegt werden:
  - `frontend/src/modules/[module]/pages/[Feature]Page.tsx`
  - Beispiele: `EmployeesPage.tsx`, `OnboardingPage.tsx`, `ReportsPage.tsx`, `StatsPage.tsx`
- Der Modul-Router MUSS alle Feature-Pages per Route erreichbar machen:
  - `/[module]/[feature]` → rendert die korrekte `[Feature]Page`
- Die Sidebar MUSS ein Submenu mit Einträgen für alle Feature-Pages enthalten
- Jede neue Page MUSS Loading-, Error- und Empty-States gemäß Standard implementieren und die Auth-Header bei API-Calls verwenden

### Dashboard-Integration (Pflicht)
- `frontend/src/components/Dashboard.tsx` um eine Modul-Kachel/-Sektion erweitern:
  - Titel: Modulname (Icon optional)
  - Kurzbeschreibung (1–2 Sätze)
  - Link/Action: Button zur Modul-Startseite (`/[module]`)
  - Optional: einfache Kennzahlen (falls verfügbar)
- Kachel-Layout, Klassen und Stil gemäß bestehenden Dashboard-Karten verwenden.

### Dokumentation & Scripte (Pflicht)
- `docs/modules/[module]/` erstellen (README.md, API.md, CHANGELOG.md)
- `docs/DOCUMENTATION_OVERVIEW.md` und `docs/INTERDEPENDENCY.md` um neues Modul und Abhängigkeiten ergänzen
- PowerShell-Skripte anpassen (Tests/Checks), falls relevant

Hinweis: Module ohne vollständige Backend-Registrierung, Frontend-Router-Integration und Sidebar-Navigation werden nicht angenommen. Für jedes neue Modul müssen die Routen in `App.tsx` registriert und passende Navigationseinträge in `Sidebar.tsx` ergänzt werden.

Zusätzlich ist die Dashboard-Integration Pflicht: Für jedes neue Modul muss eine Kachel im Dashboard vorhanden sein, die zur Route `/[module]` führt und das Modul kurz beschreibt.

## Frontend-Standards (React + TypeScript)

### Frontend-Modulstruktur - Befolge IMMER:
```
frontend/src/
├── layouts/                    # Layout-Komponenten (wiederverwendbar)
│   ├── MainLayout.tsx         # Haupt-Layout mit Header + Sidebar
│   ├── AuthLayout.tsx         # Login/Auth-Layout
│   └── components/
│       ├── Header.tsx         # Globaler Header
│       └── Sidebar.tsx        # Navigation-Sidebar
├── modules/                   # Modulbasierte Komponenten
│   ├── [module]/
│   │   ├── [Module]Module.tsx # Haupt-Modul mit Router
│   │   ├── pages/            # Seiten-Komponenten
│   │   │   ├── [Page]Page.tsx
│   │   │   └── [Page]Page.tsx
│   │   └── styles/
│   │       └── [Module]Pages.css
│   └── auth/
│       └── LoginPage.tsx
├── components/                # Globale UI-Komponenten
│   ├── Dashboard.tsx
│   └── [Component].tsx
└── App.tsx                   # Router-Konfiguration
```

### Frontend-Datei-Standards:

#### 1. Modul-Router-Pattern:
```typescript
// [Module]Module.tsx - IMMER diese Struktur
import React from 'react';
import { Routes, Route, Navigate } from 'react-router-dom';
import [Page]Page from './pages/[Page]Page';

const [Module]Module: React.FC = () => {
  return (
    <div className="[module]-module">
      <Routes>
        <Route path="/" element={<Navigate to="/[module]/[default]" replace />} />
        <Route path="/[page]" element={<[Page]Page />} />
        <Route path="*" element={<Navigate to="/[module]/[default]" replace />} />
      </Routes>
    </div>
  );
};

export default [Module]Module;
```

#### 2. Page-Komponenten-Pattern:
```typescript
// pages/[Page]Page.tsx - IMMER diese Struktur
import React, { useState, useEffect } from 'react';
import '../styles/[Module]Pages.css';

interface [Entity] {
  id: string;
  // weitere Properties
}

const [Page]Page: React.FC = () => {
  const [data, setData] = useState<[Entity][]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    loadData();
  }, []);

  const loadData = async () => {
    try {
      setLoading(true);
      setError(null);

      const token = localStorage.getItem('authToken');
      const response = await fetch('http://localhost:5000/api/[module]/[endpoint]', {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });

      const result = await response.json();
      if (result.success && result.data) {
        setData(result.data.data || result.data);
      } else {
        setError(result.message || 'Fehler beim Laden');
      }
    } catch (err) {
      setError('Verbindungsfehler zum Backend');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="[module]-page">
      <div className="page-header">
        <div className="page-title">
          <h1>[Icon] [Title]</h1>
          <p>[Description]</p>
        </div>
        <div className="page-actions">
          <button className="btn btn-primary">
            [Action]
          </button>
        </div>
      </div>

      <div className="content-section">
        {/* Content hier */}
      </div>
    </div>
  );
};

export default [Page]Page;
```

#### 3. CSS-Standards - Folge IMMER diesen Klassen:
```css
/* Basis-Layout-Klassen */
.[module]-page          # Haupt-Container
.page-header           # Header mit Titel und Actions
.page-title            # Titel-Bereich
.page-actions          # Button-Bereich
.content-section       # Haupt-Inhalt
.filters-section       # Filter-Bereich
.page-summary          # Zusammenfassung unten

/* Button-Klassen */
.btn                   # Basis-Button
.btn-primary           # Haupt-Action (blau)
.btn-secondary         # Sekundär-Action (grau)
.btn-success           # Erfolg-Action (grün)
.btn-small             # Kleine Buttons
.btn-outline           # Umrandete Buttons

/* Status-Klassen */
.loading-state         # Loading-Zustand
.error-state           # Fehler-Zustand
.empty-state           # Leerer Zustand

/* Layout-Modi */
.main-layout.fullwidth # Vollbild-Layout
.main-layout.compact   # Kompaktes Layout
```

### API-Integration-Standards:

#### 1. Authentifizierung - IMMER verwenden:
```typescript
const token = localStorage.getItem('authToken');
const headers = {
  'Authorization': `Bearer ${token}`,
  'Content-Type': 'application/json'
};
```

#### 2. Error-Handling - IMMER implementieren:
```typescript
try {
  // API-Call
} catch (err) {
  setError('Verbindungsfehler zum Backend');
  console.error('Fehler beim [Action]:', err);
}
```

#### 3. Loading-States - IMMER verwenden:
```typescript
const [loading, setLoading] = useState(true);

// In JSX:
{loading && (
  <div className="loading-state">
    <div className="loading-spinner"></div>
    <p>Lade [Data]...</p>
  </div>
)}
```

### Router-Integration-Standards:

#### 1. App.tsx - Router-Struktur:
```typescript
// IMMER diese Router-Struktur befolgen
<Router>
  <Routes>
    <Route path="/login" element={
      <AuthLayout><LoginPage /></AuthLayout>
    } />
    <Route path="/[module]/*" element={
      <MainLayout><[Module]Module /></MainLayout>
    } />
    <Route path="*" element={<Navigate to="/" replace />} />
  </Routes>
</Router>
```

#### 2. Layout-Integration - Module nutzen Layouts automatisch:
```typescript
// Layout wird durch Router bereitgestellt, nicht direkt importiert
// Module erhalten Layout-Context automatisch
```

### State-Management-Standards:

#### 1. Lokaler State für Seiten-Daten:
```typescript
const [data, setData] = useState<Type[]>([]);
const [loading, setLoading] = useState(true);
const [error, setError] = useState<string | null>(null);
const [filters, setFilters] = useState({ /* filter object */ });
```

#### 2. localStorage für User-Daten:
```typescript
// Authentifizierung
localStorage.getItem('authToken')
localStorage.getItem('userRole')
localStorage.getItem('userName')
```

### Naming-Conventions Frontend:

#### Komponenten:
- PascalCase: `EmployeesPage.tsx`, `HeaderComponent.tsx`
- Seiten enden mit `Page`: `EmployeesPage`, `DashboardPage`
- Module enden mit `Module`: `HRModule`, `SupportModule`

#### CSS-Klassen:
- kebab-case: `.employee-card`, `.ticket-list`
- Modul-Präfix: `.hr-page`, `.support-module`
- Status-Präfix: `.status-active`, `.priority-high`

#### Dateien:
- Komponenten: PascalCase.tsx
- Styles: PascalCase.css oder kebab-case.css
- Module-Ordner: lowercase mit Bindestrich

## Frontend-Integration-Checkliste:

### Bei JEDEM neuen Frontend-Modul:
1. ✅ Modul-Ordner in `src/modules/[module]/` erstellen
2. ✅ `[Module]Module.tsx` mit Router-Setup
3. ✅ `pages/` Ordner mit mindestens einer Seite
4. ✅ `styles/[Module]Pages.css` für Modul-Styles
5. ✅ Integration in `App.tsx` Router
6. ✅ Navigation in `Sidebar.tsx` hinzufügen
7. ✅ API-Integration mit Backend-Endpunkten
8. ✅ Error-Handling und Loading-States
9. ✅ Responsive Design testen
10. ✅ **KRITISCH: Dokumentations-Wartung**
    - docs/DOCUMENTATION_OVERVIEW.md um Frontend-Inhalte erweitern
    - docs/INTERDEPENDENCY.md um Frontend-Dependencies erweitern
    - docs/modules/[module]/README.md um Frontend-Sektion erweitern
    - docs/README.md Frontend-Features aktualisieren

## Frontend NICHT ERLAUBT:
❌ Direkte Layout-Imports in Modulen
❌ Inline-Styles statt CSS-Klassen
❌ API-Calls ohne Error-Handling
❌ Fehlende Loading-States
❌ Untypisierte Komponenten-Props
❌ Fehlende Responsive-Design
❌ Module ohne Router-Integration
❌ Authentifizierung umgehen
❌ Frontend-Module ohne Dokumentations-Updates
❌ Neue Pages ohne INTERDEPENDENCY.md Dependencies-Update
❌ CSS-Änderungen ohne Shared-Component-Dokumentation

## Modul-Entfernung und Löschung (KRITISCH)

Wenn ein Modul entfernt oder gelöscht werden soll, MÜSSEN ALLE Abhängigkeiten systematisch entfernt werden:

### Backend-Entfernung (Pflicht):
```bash
1. ✅ backend/src/modules/[module]/ - Kompletten Ordner löschen
2. ✅ backend/src/app.ts - Import und register[Module]Routes() entfernen
3. ✅ backend/src/app.ts - Modul aus /api/health und /api/hello Endpunkten entfernen
4. ✅ Alle Tests die das Modul referenzieren löschen/anpassen
5. ✅ Package.json Dependencies prüfen (falls modul-spezifische Packages)
```

### Frontend-Entfernung (Pflicht):
```bash
1. ✅ frontend/src/modules/[module]/ - Kompletten Ordner löschen
2. ✅ frontend/src/App.tsx - Route "/[module]/*" komplett entfernen
3. ✅ frontend/src/layouts/components/Sidebar.tsx - Navigation-Eintrag entfernen
4. ✅ frontend/src/components/Dashboard.tsx - Modul-Kachel entfernen
5. ✅ Alle Imports/Referenzen auf das Modul in anderen Komponenten entfernen
6. ✅ CSS-Klassen prüfen die modul-spezifisch waren (falls global verwendet)
```

### Dokumentations-Entfernung (KRITISCH):
```bash
1. ✅ docs/modules/[module]/ - Kompletten Ordner löschen
2. ✅ docs/DOCUMENTATION_OVERVIEW.md - Modul-Referenzen entfernen
3. ✅ docs/INTERDEPENDENCY.md - Alle Dependencies zum Modul entfernen
4. ✅ docs/README.md - Modul aus Listen und Metriken entfernen
5. ✅ docs/CHANGELOG.md - Eintrag über Modul-Entfernung hinzufügen:
   ```markdown
   ## [Version] - [Datum]
   ### Entfernt
   - **[Module] Modul komplett entfernt**
     - Backend: Ordner, Routen, Tests
     - Frontend: Komponenten, Router, Navigation, Dashboard-Kachel
     - Dokumentation: Modul-Docs, Dependencies, Referenzen
     - Grund: [Begründung für Entfernung]
   ```
```

### Vollständigkeits-Check nach Modul-Entfernung:
```bash
✅ Keine Backend-Imports/Routes mehr vorhanden?
✅ Keine Frontend-Components/Routes mehr vorhanden?
✅ Alle Navigation-Links entfernt?
✅ Dashboard ohne Modul-Kachel?
✅ Dokumentation komplett bereinigt?
✅ CHANGELOG.md dokumentiert Entfernung?
✅ Keine broken Links in verbleibender Dokumentation?
✅ Tests laufen noch durch?
✅ Frontend startet ohne Fehler?
✅ Backend startet ohne Fehler?
```

### Entfernungs-Reihenfolge (Empfohlen):
```bash
1. 🔴 CHANGELOG.md - Entfernung dokumentieren (mit Begründung)
2. 🔄 Frontend - Routen, Navigation, Dashboard bereinigen
3. 🔄 Backend - Ordner, Imports, Routen entfernen
4. 📚 Dokumentation - Referenzen und Dependencies bereinigen
5. ✅ Tests - Vollständigkeits-Check durchführen
```

### NICHT ERLAUBT bei Modul-Entfernung:
❌ Modul-Ordner löschen ohne Route-Bereinigung
❌ Backend/Frontend teilweise entfernt lassen
❌ Navigation-Links zu gelöschtem Modul
❌ Broken Dashboard-Kacheln
❌ Verwaiste Dokumentations-Referenzen
❌ Fehlende CHANGELOG.md Dokumentation der Entfernung
❌ Dependencies in INTERDEPENDENCY.md nicht bereinigt
❌ Tests die auf gelöschte Module verweisen

**Wichtig**: Eine Modul-Entfernung ist ein Breaking Change und MUSS ausführlich in docs/CHANGELOG.md dokumentiert werden, inklusive Begründung und Auswirkungen auf andere Module.

Diese Regeln gewährleisten Konsistenz, Wartbarkeit und Skalierbarkeit der CompanyAI-Architektur.
