# CompanyAI - Modulbasierte Architektur Regeln
# Diese Regeln gelten ALLGEMEIN f√ºr ALLE Module (Backend und Frontend).
# Spezifische Beispiele d√ºrfen niemals als Ausnahmen interpretiert werden ‚Äì
# jede neue Modul-Implementation muss diese Standards vollst√§ndig erf√ºllen.

## Modulstruktur Standards

Befolge IMMER diese modulbasierte Ordnerstruktur f√ºr alle Module in `backend/src/modules/`:

### Pflicht-Struktur f√ºr jedes neue Modul:
```
backend/src/modules/[module-name]/
‚îú‚îÄ‚îÄ orchestrator.ts        # PFLICHT: API-Route-Handler und Koordination
‚îú‚îÄ‚îÄ types.ts              # PFLICHT: TypeScript-Interfaces und Typen
‚îú‚îÄ‚îÄ core/                 # OPTIONAL: Wiederverwendbare Hilfslogik
‚îÇ   ‚îî‚îÄ‚îÄ [helper-files].ts # z.B. auth.ts, utils.ts, validators.ts
‚îî‚îÄ‚îÄ functions/            # PFLICHT: Gesch√§ftslogik-Funktionen
    ‚îú‚îÄ‚îÄ [function1].ts    # Eine Funktion pro Datei
    ‚îú‚îÄ‚îÄ [function2].ts    # Klare, beschreibende Namen
    ‚îî‚îÄ‚îÄ [function3].ts    # Export von async functions
```

## Datei-Standards

### 1. types.ts - IMMER enthalten:
```typescript
// Input-Request-Typen
export interface Create[Entity]Request { ... }
export interface Update[Entity]Request { ... }
export interface Search[Entity]Request { ... }

// Entity-Typen
export interface [Entity] { 
  id: string;
  // weitere Properties
}

// Response-Typen
export interface APIResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
}

export interface PaginatedResponse<T> {
  data: T[];
  pagination: {
    total: number;
    page: number;
    limit: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
}
```

### 2. orchestrator.ts - IMMER enthalten:
```typescript
import { Request, Response } from 'express';
import { AuthenticatedRequest } from '../hr/core/auth'; // Zentrale Auth nutzen

export class [Module]Orchestrator {
  static async handle[Action](req: AuthenticatedRequest, res: Response) {
    // Handler-Implementation
  }
}

export function register[Module]Routes(router: any) {
  // Route-Registrierung
}
```

### 3. functions/[function].ts - Eine Funktion pro Datei:
```typescript
import { [Entity], [Request]Type, APIResponse } from '../types';

export async function [functionName](
  request: [Request]Type
): Promise<APIResponse<[Entity]>> {
  try {
    // Implementation
    return { success: true, data: result, message: 'Success' };
  } catch (error) {
    return { success: false, error: 'Error', message: 'Failed' };
  }
}
```

## Integration-Standards

### Neue Module M√úSSEN in backend/src/index.ts registriert werden:
1. Import hinzuf√ºgen: `import { register[Module]Routes } from './modules/[module]/orchestrator';`
2. Route registrieren: `register[Module]Routes(apiRouter);`
3. Module-Liste aktualisieren in health/hello endpoints
4. Dokumentation in availableModules erg√§nzen

### Authentifizierung - IMMER nutzen:
- Import: `import { AuthenticatedRequest, requireAuth, requirePermission } from '../hr/core/auth';`
- F√ºr gesch√ºtzte Routes: `requireAuth` oder `requirePermission(action, resource)`
- Logging: `logAuthEvent(userId, action, resource)`

## Naming Conventions

### Module-Namen:
- Kleinschreibung mit Bindestrichen: `hr`, `support`, `user-management`
- Beschreibende Namen, nicht zu allgemein

### API-Routen:
- RESTful: `/api/[module]/[entities]`
- Beispiele: `/api/hr/employees`, `/api/support/tickets`

### Funktions-Namen:
- Verben verwenden: `createEmployee`, `fetchTickets`, `generateReport`
- Async functions f√ºr alle Gesch√§ftslogik
- Klare, beschreibende Namen

### Datei-Namen:
- camelCase f√ºr Functions: `createHRReport.ts`, `manageTickets.ts`
- Beschreibende Namen, die den Inhalt widerspiegeln

## Code-Standards

### Error Handling:
```typescript
try {
  // Implementation
  return { success: true, data: result, message: 'Success message' };
} catch (error) {
  console.error('Descriptive error message:', error);
  return {
    success: false,
    error: 'User-friendly error type',
    message: 'German error message for user'
  };
}
```

### Validation:
- Immer Request-Daten validieren
- Separate Validation-Funktionen erstellen
- Fr√ºh validieren, fr√ºh zur√ºckgeben bei Fehlern

### Responses:
- IMMER APIResponse<T> Format verwenden
- Deutsche Fehlermeldungen f√ºr User
- Englische Fehler-Types f√ºr Logging
- Konsistente HTTP-Status-Codes

## PowerShell Kompatibilit√§t
- Bevorzuge `;` statt `&&` in npm scripts
- Erstelle .ps1 Scripts f√ºr Module-spezifische Tasks
- Nutze PowerShell-freundliche Pfade

## Dokumentation Standards

### Markdown-Dokumentations-Policy (KRITISCH)
- Alle Dokumentations-Dateien mit Endung `.md` M√úSSEN unter `docs/` liegen.
- Erlaubte Ausnahmen:
  - `README.md` im Repository-Root (Projekt-Overview)
  - `frontend/README.md` und `backend/README.md` (nur falls unbedingt n√∂tig; bevorzugt Inhalte in `docs/` konsolidieren)
- Nicht erlaubt:
  - Markdown-Dokumente au√üerhalb von `docs/` (z. B. Roadmaps, API-Beschreibungen, Architektur-Notizen) ‚Äì diese m√ºssen nach `docs/` verschoben werden.
- Vorgeschriebene Pfadkonventionen in `docs/`:
  - Globale Dokumente: `docs/README.md`, `docs/CHANGELOG.md`, `docs/DOCUMENTATION_OVERVIEW.md`, `docs/INTERDEPENDENCY.md`, `docs/IMPROVEMENTS_ROADMAP.md`
  - Modul-Dokumente: `docs/modules/[module]/README.md`, `docs/modules/[module]/API.md`, `docs/modules/[module]/CHANGELOG.md`
  - Architektur: `docs/architecture/overview.md`, `docs/architecture/module-guidelines.md`
- PR/Review-Regel: PRs mit `.md`-Dateien au√üerhalb von `docs/` (au√üer den oben genannten Ausnahmen) werden abgelehnt ‚Äì Dateien m√ºssen in die korrekte `docs/`-Struktur verschoben werden.
- Bei Verschiebungen von `.md` in `docs/` sind alle internen Links zu aktualisieren.

### PR/Review-Gates f√ºr DataSources/Integrations (KRITISCH)
- Jeder PR, der DataSources/Integrations √§ndert (z. B. neue Quelle, externe API, .env-Variablen, Sync-Mechanismen), MUSS folgende Dokumente aktualisieren ‚Äì andernfalls wird der PR abgelehnt:
  - `docs/INTERDEPENDENCY.md` (DataSources-Dependencies, Environment-Dependencies, External-API-Dependencies, Sync-Dependencies, Cross-DataSource-Logic, Frontend-API-Bindings, Source-Typen manual/external)
  - `docs/DOCUMENTATION_OVERVIEW.md` (Integration-Architektur und Dokumentationsstruktur)
  - `docs/CHANGELOG.md` (versionierte √Ñnderung an Integrationen)
  - Falls von einem Modul konsumiert: `docs/modules/[module]/README.md` (Nutzung/Abh√§ngigkeiten) und `docs/modules/[module]/API.md` (genutzte Endpunkte, z. B. `/api/data/*`)
  - Falls AI/RAG betroffen: `docs/RAG_DATA_SOURCES.md` (Quelle, Umfang, PII-Richtlinien)
  - Falls Security/PII betroffen: `docs/AI_SECURITY_POLICY.md` (Scopes, Token-Flows, PII in Logs unterbinden)
  - Falls Logging-Fl√ºsse betroffen: `docs/LOGGING_STRATEGY.md` (Events, reqId, Retention)

### PR/Review-Gates f√ºr Frontend Theme & Layout-Konfiguration (KRITISCH)
- Jede √Ñnderung an Frontend-Theme-Parametern (z. B. Farben, Branding, Layout-Variablen) MUSS folgende Updates enthalten:
  - `frontend/.env` (oder entsprechende ENV-Datei) aktualisieren: Neue/angepasste `VITE_*` Variablen f√ºr Theme/Branding
  - `docs/INTERDEPENDENCY.md`: Abschnitt "Frontend-Theme/Branding" erweitern/aktualisieren (Environment-Dependencies, betroffene Komponenten wie `Header`, `Sidebar`, CSS-Variables)
  - `docs/DOCUMENTATION_OVERVIEW.md`: Dokumentationsstatus und ENV-Beispiel erweitern (Theme-Variablen auflisten)
  - `docs/CHANGELOG.md`: Versionierte UI/UX-√Ñnderungen dokumentieren
  - Konsistenz pr√ºfen: CSS-Custom-Properties (`--*`) in globalen Styles referenzieren; keine Hardcodes in Komponenten

### Jedes neue Modul MUSS dokumentiert werden (Pflicht)
```
docs/modules/[module-name]/
‚îú‚îÄ‚îÄ README.md           # Vollst√§ndige Modul-Dokumentation
‚îú‚îÄ‚îÄ API.md             # Detaillierte API-Dokumentation
‚îî‚îÄ‚îÄ CHANGELOG.md       # Versionierung und √Ñnderungen
```

- F√ºr JEDE √Ñnderung an Endpunkten, Routen oder Strukturen des Moduls: `docs/modules/[module]/API.md` sofort aktualisieren (inkl. Request/Response-Beispiele, Statuscodes, Auth-Requirements)
- F√ºr JEDE neue Funktion/Feature im Modul: `docs/modules/[module]/README.md` um Funktionsbeschreibung, Sicherheit, Abh√§ngigkeiten und Limitierungen erweitern
- F√ºr JEDE produktive √Ñnderung: `docs/modules/[module]/CHANGELOG.md` um Version/Datum/√Ñnderung erg√§nzen
- Globale √úbersichten IMMER aktualisieren: `docs/DOCUMENTATION_OVERVIEW.md`, `docs/INTERDEPENDENCY.md`, `docs/CHANGELOG.md` (siehe Wartungspflichten)

## Dokumentations-Wartung (KRITISCH)

### Bei JEDER √Ñnderung in docs/ - UPDATE PFLICHT:

#### 1. DOCUMENTATION_OVERVIEW.md aktualisieren:
```typescript
// Bei neuen Dokumenten in docs/:
// ‚úÖ Dokumentationsstruktur-Tree erweitern
// ‚úÖ Neue Datei in entsprechender Sektion beschreiben
// ‚úÖ Umfang (Zeilen) und Abdeckung dokumentieren
// ‚úÖ Wichtigkeit und Nutzung angeben

// Bei √Ñnderungen an bestehenden Docs:
// ‚úÖ Umfang (Zeilen) aktualisieren
// ‚úÖ Abdeckung um neue Inhalte erweitern
// ‚úÖ Status bei Fertigstellung anpassen
```

#### 2. INTERDEPENDENCY.md aktualisieren bei:
```typescript
// Backend-√Ñnderungen:
// ‚úÖ Neue Module ‚Üí Backend-Module-Dependencies erweitern
// ‚úÖ Neue Auth-Mechanismen ‚Üí Authentifizierung-Sektion updaten
// ‚úÖ Neue API-Patterns ‚Üí API-Integration-Standards erweitern
// ‚úÖ Neue orchestrator/types ‚Üí Template-Referenzen aktualisieren

// Frontend-√Ñnderungen:
// ‚úÖ Neue Module ‚Üí Frontend-Module-Dependencies erweitern
// ‚úÖ Neue Layout-Komponenten ‚Üí Layout-System-Sektion updaten
// ‚úÖ Neue CSS-Klassen ‚Üí CSS-Klassen-System erweitern
// ‚úÖ Neue Router-Patterns ‚Üí Router-Integration-Standards updaten

// DataSources/Integrations-√Ñnderungen (KRITISCH):
// ‚úÖ Neue DataSources ‚Üí DataSources-Dependencies-Sektion erweitern
// ‚úÖ .env Variablen ‚Üí Environment-Dependencies dokumentieren
// ‚úÖ Externe APIs (z. B. Microsoft Graph) ‚Üí External-API-Dependencies hinzuf√ºgen
// ‚úÖ Sync-Mechanismen ‚Üí Sync-Dependencies dokumentieren (Trigger, Intervalle, Startbedingungen)
// ‚úÖ Cross-DataSource Dependencies ‚Üí Combined-Logic dokumentieren
// ‚úÖ Frontend-DataSource-Bindings ‚Üí Frontend-API-Dependencies updaten
// ‚úÖ Source-Typen (manual/external) ‚Üí Source-Type-Dependencies dokumentieren

// Shared Dependencies:
// ‚úÖ Neue Auth-Logik ‚Üí Kritische Abh√§ngigkeiten erweitern
// ‚úÖ Neue API-Calls ‚Üí API-Pattern-Dokumentation updaten
// ‚úÖ Breaking Changes ‚Üí Breaking Change Prevention Liste erweitern
// ‚úÖ Neue Integration-Guidelines hinzuf√ºgen
```

### AUTOMATISCHE DOKUMENTATIONS-UPDATES:

#### Bei neuen Backend-Modulen:
```bash
# PFLICHT-Updates:
1. ‚úÖ docs/modules/[module]/README.md erstellen
2. ‚úÖ docs/modules/[module]/API.md erstellen  
3. ‚úÖ docs/modules/[module]/CHANGELOG.md erstellen
4. ‚úÖ docs/DOCUMENTATION_OVERVIEW.md - Modul-Sektion hinzuf√ºgen
5. ‚úÖ docs/INTERDEPENDENCY.md - Backend-Dependencies erweitern
6. ‚úÖ docs/README.md - Module-Liste und Metriken aktualisieren
7. ‚úÖ docs/CHANGELOG.md - Version und Features hinzuf√ºgen
```

#### Bei neuen Frontend-Modulen:
```bash
# PFLICHT-Updates:
1. ‚úÖ docs/modules/[module]/README.md um Frontend-Sektion erweitern
2. ‚úÖ docs/DOCUMENTATION_OVERVIEW.md - Frontend-Inhalte hinzuf√ºgen
3. ‚úÖ docs/INTERDEPENDENCY.md - Frontend-Dependencies erweitern
4. ‚úÖ docs/README.md - Frontend-Features aktualisieren
5. ‚úÖ docs/CHANGELOG.md - UI/UX √Ñnderungen dokumentieren
```

#### Bei neuen DataSources/Integrations (KRITISCH):
```bash
# SOFORT-Updates:
1. ‚úÖ docs/INTERDEPENDENCY.md - DataSources-Dependencies-Sektion erweitern
2. ‚úÖ docs/INTERDEPENDENCY.md - Environment-Variables (.env) dokumentieren
3. ‚úÖ docs/INTERDEPENDENCY.md - External-API-Dependencies hinzuf√ºgen
4. ‚úÖ docs/INTERDEPENDENCY.md - Frontend-API-Bindings dokumentieren
5. ‚úÖ docs/DOCUMENTATION_OVERVIEW.md - Integration-Architektur erweitern
6. ‚úÖ docs/CHANGELOG.md - Integration-Changes dokumentieren
7. ‚úÖ docs/README.md - Neue Capabilities hinzuf√ºgen
```

#### Bei API-√Ñnderungen:
```bash
# SOFORT-Updates:
1. ‚úÖ docs/modules/[module]/API.md - Endpunkt-Dokumentation aktualisieren
2. ‚úÖ docs/INTERDEPENDENCY.md - API-Integration-Standards anpassen
3. ‚úÖ docs/modules/[module]/CHANGELOG.md - API-Changes dokumentieren
4. ‚úÖ docs/CHANGELOG.md - Breaking Changes dokumentieren (falls vorhanden)
```

#### Bei Architektur-√Ñnderungen:
```bash
# KRITISCHE Updates:
1. ‚úÖ docs/INTERDEPENDENCY.md - Vollst√§ndige Dependency-Review
2. ‚úÖ docs/architecture/overview.md - System-Architektur aktualisieren
3. ‚úÖ docs/architecture/module-guidelines.md - Guidelines anpassen
4. ‚úÖ docs/DOCUMENTATION_OVERVIEW.md - Architektur-Sektion updaten
5. ‚úÖ .cursorrules - Standards bei Breaking Changes anpassen
```

### Dokumentations-Inhalte:
1. **README.md:**
   - Modul-√úbersicht mit Zweck und Status
   - Implementierte Funktionen
   - Technische Implementation
   - Sicherheit & Berechtigungen
   - Performance-Metriken
   - Bekannte Limitierungen
   - Roadmap & Entwicklungsplan

2. **API.md:**
   - Alle API-Endpunkte dokumentiert
   - Request/Response-Beispiele
   - Error-Handling-Szenarien
   - PowerShell-Test-Beispiele
   - Authentifizierungs-Requirements

3. **CHANGELOG.md:**
   - Versionierte √Ñnderungshistorie
   - Was hinzugef√ºgt/ge√§ndert/entfernt wurde
   - Technische Details zu Updates
   - Geplante Verbesserungen

### Dokumentations-Updates:
- Bei JEDEM neuen Feature: Dokumentation aktualisieren
- Bei API-√Ñnderungen: API.md sofort updaten
- Bei Breaking Changes: CHANGELOG.md ausf√ºhrlich dokumentieren
- Haupt-README.md bei neuen Modulen erweitern

## Testing
- Test-Funktionen in orchestrator f√ºr jedes Modul
- PowerShell-Test-Scripts erstellen
- Mock-Daten f√ºr Entwicklung bereitstellen

## NICHT ERLAUBT:
‚ùå Module ohne orchestrator.ts
‚ùå Module ohne types.ts  
‚ùå Gesch√§ftslogik direkt in orchestrator.ts
‚ùå Fehlende Error-Handling
‚ùå Untypisierte API-Responses
‚ùå Module ohne Authentifizierung
‚ùå Direkte Datenbankzugriffe ohne Abstraktionsschicht
‚ùå Module, die nicht in index.ts registriert sind
‚ùå Module ohne Dokumentation in docs/modules/
‚ùå API-√Ñnderungen ohne Dokumentations-Update
‚ùå Neue Module ohne DOCUMENTATION_OVERVIEW.md Update
‚ùå Abh√§ngigkeits-√Ñnderungen ohne INTERDEPENDENCY.md Update
‚ùå Frontend-Module ohne Frontend-Dokumentation in bestehenden docs/modules/
‚ùå Neue Features ohne docs/CHANGELOG.md Eintrag
‚ùå Breaking Changes ohne ausf√ºhrliche Dokumentation
‚ùå DataSources/Integrations ohne INTERDEPENDENCY.md Dependencies-Update
‚ùå .env √Ñnderungen ohne Environment-Dependencies-Dokumentation
‚ùå Externe API-Integrationen ohne External-API-Dependencies-Dokumentation

## Module ‚Üî DataSources Consumption (KRITISCH)

Diese Regeln gelten f√ºr JEDES Modul, das Daten aus `backend/src/datasources/` liest oder schreibt.

### Grunds√§tze
- **Lesen:** Standard ist die kombinierte Quelle (entra + manual) via `entraac/combined.ts`.
  - Verwende ausschlie√ülich zentrale Re-Exports: `import { getCombinedUsers, findCombinedUsers, getCombinedStats, createManualUser, updateManualUser, deleteManualUser } from '../../datasources';`
  - Kein direkter Zugriff auf externe APIs (z. B. Microsoft Graph) aus Modulen.
- **Schreiben:** Ausschlie√ülich in die manuelle Quelle (`manual`). `entra` ist strikt read-only.
- **Mapping-Standard (Combined ‚Üí Modul-Entity):**
  - `displayName` ‚Üí `firstName`/`lastName`
  - `mail`/`userPrincipalName` ‚Üí `email`
  - `jobTitle` ‚Üí `position`
  - `department` ‚Üí `department`
  - `accountEnabled` ‚Üí `status` (active/inactive/pending)
- **Audit & Security:**
  - `logAuthEvent(userId, action, resource)` in Orchestrator-Handlern verwenden
  - `requireAuth`/`requirePermission` strikt einsetzen
  - Keine PII in Logs

### Pflichten bei Modul‚ÜîDataSources-Verkn√ºpfung (PR/Review-Checklist)
1. Code-Integration
   - [ ] Nur zentrale Re-Exports aus `backend/src/datasources/index.ts` importiert
   - [ ] Lesezugriffe √ºber `getCombinedUsers`/`findCombinedUsers`
   - [ ] Schreibzugriffe nur √ºber `createManualUser`/`updateManualUser`/`deleteManualUser`
   - [ ] Einheitliches Mapping auf Modul-Entities implementiert
   - [ ] Vollst√§ndiges Error-Handling (engl. Error-Typ, dt. User-Message)
   - [ ] `createdBy`/`updatedBy` beim Schreiben gesetzt (wenn verf√ºgbar)
2. Dokumentation (PFLICHT)
   - [ ] `docs/INTERDEPENDENCY.md`: Modul-spezifische Bindings erg√§nzt (lesen=combined, schreiben=manual, Stats, Mapping)
   - [ ] `docs/modules/[module]/README.md`: DataSources-Integration beschrieben
   - [ ] `docs/modules/[module]/API.md`: Endpunkt-Semantik (combined/manual) dokumentiert
   - [ ] `docs/CHANGELOG.md`: Unver√∂ffentlicht ‚Üí ‚ÄûDocs/Integrations‚Äú Eintrag
   - [ ] `docs/DOCUMENTATION_OVERVIEW.md`: Umfang/Abdeckung aktualisiert
3. API/Contracts
   - [ ] Keine Breaking Changes ohne Changelog + Doc-Updates
   - [ ] Response-Typen im Modul `types.ts` konsistent mit Mapping
4. Tests
   - [ ] PowerShell-Tests f√ºr read (combined) und write (manual)
   - [ ] Error-Szenarien (Forbidden f√ºr `entra`-Writes) abgedeckt

### Nicht erlaubt (Hard-Fails)
- ‚ùå Direkte externe API-Calls (Graph) aus Modulen
- ‚ùå Schreiben in `entra`
- ‚ùå Umgehen der zentralen DataSources-Re-Exports
- ‚ùå Abweichende Mapping-Keys ohne Dokumentation/Types-Update
- ‚ùå Verkn√ºpfungen ohne Doku-Updates gem√§√ü Pflichtliste

## Bei JEDEM neuen Modul:
1. ‚úÖ Ordnerstruktur nach Standard erstellen
2. ‚úÖ types.ts mit allen n√∂tigen Interfaces
3. ‚úÖ functions/ mit separaten Funktionsdateien  
4. ‚úÖ orchestrator.ts mit Route-Handlern
5. ‚úÖ Integration in index.ts
6. ‚úÖ Vollst√§ndige Dokumentation erstellen:
   - docs/modules/[module]/README.md
   - docs/modules/[module]/API.md
   - docs/modules/[module]/CHANGELOG.md
7. ‚úÖ **KRITISCH: Dokumentations-Wartung**
   - docs/DOCUMENTATION_OVERVIEW.md erweitern
   - docs/INTERDEPENDENCY.md um Dependencies erweitern
   - docs/README.md Module-Liste aktualisieren
   - docs/CHANGELOG.md Version hinzuf√ºgen
8. ‚úÖ Test-Script erweitern
9. ‚úÖ Haupt-Dokumentation aktualisieren

## Bei JEDER neuen DataSource/Integration:
1. ‚úÖ Ordnerstruktur in `backend/src/datasources/[source]/` erstellen
2. ‚úÖ Types, Store, Client/Sync-Logik implementieren
3. ‚úÖ API-Routes in `backend/src/app.ts` registrieren
4. ‚úÖ .env Variablen hinzuf√ºgen und dokumentieren
5. ‚úÖ **KRITISCH: INTERDEPENDENCY.md aktualisieren**
   - DataSources-Dependencies-Sektion erweitern
   - Environment-Variables (.env) dokumentieren
   - External-API-Dependencies hinzuf√ºgen
   - Frontend-API-Bindings dokumentieren
   - Cross-DataSource Dependencies dokumentieren
6. ‚úÖ `docs/DOCUMENTATION_OVERVIEW.md` erweitern
7. ‚úÖ `docs/CHANGELOG.md` aktualisieren
8. ‚úÖ Frontend-Integration planen und dokumentieren

## Neue Module ‚Äì Verbindliche Backend-/Frontend-Integration (KRITISCH)

### Backend (Pflicht)
- Ordner: `backend/src/modules/[module]/` mit Struktur gem√§√ü Modulstandards (siehe oben)
- Routen-Registrierung: `register[Module]Routes(apiRouter)` in `backend/src/app.ts` hinzuf√ºgen
- Auth: `requireAuth`/`requirePermission` konsequent verwenden
- Health/Hello: Endpunkt-Liste in `/api/hello` um Modul erg√§nzen (Beschreibung + Endpunkte)
- Tests: Mindestens Health-/Routing-Test f√ºr neues Modul

### Frontend (Pflicht)
- Ordner: `frontend/src/modules/[module]/` mit:
  - `[Module]Module.tsx` (interner Router gem√§√ü Standard)
  - `pages/` (mind. eine Page-Komponente)
  - `styles/[Module]Pages.css`
- Router: In `frontend/src/App.tsx` Route f√ºr das Modul registrieren:
  - `<Route path="/[module]/*" element={<MainLayout><[Module]Module /></MainLayout>} />` (mit `RequireAuth` Wrapper)
- Navigation (Pflicht): In `frontend/src/layouts/components/Sidebar.tsx` Navigations-Eintrag hinzuf√ºgen (inkl. Submenu, falls zutreffend)
- UI-Standards: Vorhandene CSS-Klassen verwenden (page-header, content-section, etc.)

### Page-Struktur je Modul (Pflicht)
- F√ºr JEDES fachliche Feature im Modul MUSS eine eigene Page-Komponente angelegt werden:
  - `frontend/src/modules/[module]/pages/[Feature]Page.tsx`
  - Beispiele: `EmployeesPage.tsx`, `OnboardingPage.tsx`, `ReportsPage.tsx`, `StatsPage.tsx`
- Der Modul-Router MUSS alle Feature-Pages per Route erreichbar machen:
  - `/[module]/[feature]` ‚Üí rendert die korrekte `[Feature]Page`
- Die Sidebar MUSS ein Submenu mit Eintr√§gen f√ºr alle Feature-Pages enthalten
- Jede neue Page MUSS Loading-, Error- und Empty-States gem√§√ü Standard implementieren und die Auth-Header bei API-Calls verwenden

### Dashboard-Integration (Pflicht)
- `frontend/src/components/Dashboard.tsx` um eine Modul-Kachel/-Sektion erweitern:
  - Titel: Modulname (Icon optional)
  - Kurzbeschreibung (1‚Äì2 S√§tze)
  - Link/Action: Button zur Modul-Startseite (`/[module]`)
  - Optional: einfache Kennzahlen (falls verf√ºgbar)
- Kachel-Layout, Klassen und Stil gem√§√ü bestehenden Dashboard-Karten verwenden.

### Dokumentation & Scripte (Pflicht)
- `docs/modules/[module]/` erstellen (README.md, API.md, CHANGELOG.md)
- `docs/DOCUMENTATION_OVERVIEW.md` und `docs/INTERDEPENDENCY.md` um neues Modul und Abh√§ngigkeiten erg√§nzen
- PowerShell-Skripte anpassen (Tests/Checks), falls relevant

Hinweis: Module ohne vollst√§ndige Backend-Registrierung, Frontend-Router-Integration und Sidebar-Navigation werden nicht angenommen. F√ºr jedes neue Modul m√ºssen die Routen in `App.tsx` registriert und passende Navigationseintr√§ge in `Sidebar.tsx` erg√§nzt werden.

Zus√§tzlich ist die Dashboard-Integration Pflicht: F√ºr jedes neue Modul muss eine Kachel im Dashboard vorhanden sein, die zur Route `/[module]` f√ºhrt und das Modul kurz beschreibt.

## Frontend-Standards (React + TypeScript)

### Frontend-Modulstruktur - Befolge IMMER:
```
frontend/src/
‚îú‚îÄ‚îÄ layouts/                    # Layout-Komponenten (wiederverwendbar)
‚îÇ   ‚îú‚îÄ‚îÄ MainLayout.tsx         # Haupt-Layout mit Header + Sidebar
‚îÇ   ‚îú‚îÄ‚îÄ AuthLayout.tsx         # Login/Auth-Layout
‚îÇ   ‚îî‚îÄ‚îÄ components/
‚îÇ       ‚îú‚îÄ‚îÄ Header.tsx         # Globaler Header
‚îÇ       ‚îî‚îÄ‚îÄ Sidebar.tsx        # Navigation-Sidebar
‚îú‚îÄ‚îÄ modules/                   # Modulbasierte Komponenten
‚îÇ   ‚îú‚îÄ‚îÄ [module]/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [Module]Module.tsx # Haupt-Modul mit Router
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pages/            # Seiten-Komponenten
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [Page]Page.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [Page]Page.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ styles/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ [Module]Pages.css
‚îÇ   ‚îî‚îÄ‚îÄ auth/
‚îÇ       ‚îî‚îÄ‚îÄ LoginPage.tsx
‚îú‚îÄ‚îÄ components/                # Globale UI-Komponenten
‚îÇ   ‚îú‚îÄ‚îÄ Dashboard.tsx
‚îÇ   ‚îî‚îÄ‚îÄ [Component].tsx
‚îî‚îÄ‚îÄ App.tsx                   # Router-Konfiguration
```

### Frontend-Datei-Standards:

#### 1. Modul-Router-Pattern:
```typescript
// [Module]Module.tsx - IMMER diese Struktur
import React from 'react';
import { Routes, Route, Navigate } from 'react-router-dom';
import [Page]Page from './pages/[Page]Page';

const [Module]Module: React.FC = () => {
  return (
    <div className="[module]-module">
      <Routes>
        <Route path="/" element={<Navigate to="/[module]/[default]" replace />} />
        <Route path="/[page]" element={<[Page]Page />} />
        <Route path="*" element={<Navigate to="/[module]/[default]" replace />} />
      </Routes>
    </div>
  );
};

export default [Module]Module;
```

#### 2. Page-Komponenten-Pattern:
```typescript
// pages/[Page]Page.tsx - IMMER diese Struktur
import React, { useState, useEffect } from 'react';
import '../styles/[Module]Pages.css';

interface [Entity] {
  id: string;
  // weitere Properties
}

const [Page]Page: React.FC = () => {
  const [data, setData] = useState<[Entity][]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    loadData();
  }, []);

  const loadData = async () => {
    try {
      setLoading(true);
      setError(null);

      const token = localStorage.getItem('authToken');
      const response = await fetch('http://localhost:5000/api/[module]/[endpoint]', {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });

      const result = await response.json();
      if (result.success && result.data) {
        setData(result.data.data || result.data);
      } else {
        setError(result.message || 'Fehler beim Laden');
      }
    } catch (err) {
      setError('Verbindungsfehler zum Backend');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="[module]-page">
      <div className="page-header">
        <div className="page-title">
          <h1>[Icon] [Title]</h1>
          <p>[Description]</p>
        </div>
        <div className="page-actions">
          <button className="btn btn-primary">
            [Action]
          </button>
        </div>
      </div>

      <div className="content-section">
        {/* Content hier */}
      </div>
    </div>
  );
};

export default [Page]Page;
```

#### 3. CSS-Standards - Folge IMMER diesen Klassen:
```css
/* Basis-Layout-Klassen */
.[module]-page          # Haupt-Container
.page-header           # Header mit Titel und Actions
.page-title            # Titel-Bereich
.page-actions          # Button-Bereich
.content-section       # Haupt-Inhalt
.filters-section       # Filter-Bereich
.page-summary          # Zusammenfassung unten

/* Button-Klassen */
.btn                   # Basis-Button
.btn-primary           # Haupt-Action (blau)
.btn-secondary         # Sekund√§r-Action (grau)
.btn-success           # Erfolg-Action (gr√ºn)
.btn-small             # Kleine Buttons
.btn-outline           # Umrandete Buttons

/* Status-Klassen */
.loading-state         # Loading-Zustand
.error-state           # Fehler-Zustand
.empty-state           # Leerer Zustand

/* Layout-Modi */
.main-layout.fullwidth # Vollbild-Layout
.main-layout.compact   # Kompaktes Layout
```

### API-Integration-Standards:

#### 1. Authentifizierung - IMMER verwenden:
```typescript
const token = localStorage.getItem('authToken');
const headers = {
  'Authorization': `Bearer ${token}`,
  'Content-Type': 'application/json'
};
```

#### 2. Error-Handling - IMMER implementieren:
```typescript
try {
  // API-Call
} catch (err) {
  setError('Verbindungsfehler zum Backend');
  console.error('Fehler beim [Action]:', err);
}
```

#### 3. Loading-States - IMMER verwenden:
```typescript
const [loading, setLoading] = useState(true);

// In JSX:
{loading && (
  <div className="loading-state">
    <div className="loading-spinner"></div>
    <p>Lade [Data]...</p>
  </div>
)}
```

### Router-Integration-Standards:

#### 1. App.tsx - Router-Struktur:
```typescript
// IMMER diese Router-Struktur befolgen
<Router>
  <Routes>
    <Route path="/login" element={
      <AuthLayout><LoginPage /></AuthLayout>
    } />
    <Route path="/[module]/*" element={
      <MainLayout><[Module]Module /></MainLayout>
    } />
    <Route path="*" element={<Navigate to="/" replace />} />
  </Routes>
</Router>
```

#### 2. Layout-Integration - Module nutzen Layouts automatisch:
```typescript
// Layout wird durch Router bereitgestellt, nicht direkt importiert
// Module erhalten Layout-Context automatisch
```

### State-Management-Standards:

#### 1. Lokaler State f√ºr Seiten-Daten:
```typescript
const [data, setData] = useState<Type[]>([]);
const [loading, setLoading] = useState(true);
const [error, setError] = useState<string | null>(null);
const [filters, setFilters] = useState({ /* filter object */ });
```

#### 2. localStorage f√ºr User-Daten:
```typescript
// Authentifizierung
localStorage.getItem('authToken')
localStorage.getItem('userRole')
localStorage.getItem('userName')
```

### Naming-Conventions Frontend:

#### Komponenten:
- PascalCase: `EmployeesPage.tsx`, `HeaderComponent.tsx`
- Seiten enden mit `Page`: `EmployeesPage`, `DashboardPage`
- Module enden mit `Module`: `HRModule`, `SupportModule`

#### CSS-Klassen:
- kebab-case: `.employee-card`, `.ticket-list`
- Modul-Pr√§fix: `.hr-page`, `.support-module`
- Status-Pr√§fix: `.status-active`, `.priority-high`

#### Dateien:
- Komponenten: PascalCase.tsx
- Styles: PascalCase.css oder kebab-case.css
- Module-Ordner: lowercase mit Bindestrich

## Frontend-Integration-Checkliste:

### Bei JEDEM neuen Frontend-Modul:
1. ‚úÖ Modul-Ordner in `src/modules/[module]/` erstellen
2. ‚úÖ `[Module]Module.tsx` mit Router-Setup
3. ‚úÖ `pages/` Ordner mit mindestens einer Seite
4. ‚úÖ `styles/[Module]Pages.css` f√ºr Modul-Styles
5. ‚úÖ Integration in `App.tsx` Router
6. ‚úÖ Navigation in `Sidebar.tsx` hinzuf√ºgen
7. ‚úÖ API-Integration mit Backend-Endpunkten
8. ‚úÖ Error-Handling und Loading-States
9. ‚úÖ Responsive Design testen
10. ‚úÖ **KRITISCH: Dokumentations-Wartung**
    - docs/DOCUMENTATION_OVERVIEW.md um Frontend-Inhalte erweitern
    - docs/INTERDEPENDENCY.md um Frontend-Dependencies erweitern
    - docs/modules/[module]/README.md um Frontend-Sektion erweitern
    - docs/README.md Frontend-Features aktualisieren

## Frontend NICHT ERLAUBT:
‚ùå Direkte Layout-Imports in Modulen
‚ùå Inline-Styles statt CSS-Klassen
‚ùå API-Calls ohne Error-Handling
‚ùå Fehlende Loading-States
‚ùå Untypisierte Komponenten-Props
‚ùå Fehlende Responsive-Design
‚ùå Module ohne Router-Integration
‚ùå Authentifizierung umgehen
‚ùå Frontend-Module ohne Dokumentations-Updates
‚ùå Neue Pages ohne INTERDEPENDENCY.md Dependencies-Update
‚ùå CSS-√Ñnderungen ohne Shared-Component-Dokumentation

## Modul-Entfernung und L√∂schung (KRITISCH)

Wenn ein Modul entfernt oder gel√∂scht werden soll, M√úSSEN ALLE Abh√§ngigkeiten systematisch entfernt werden:

### Backend-Entfernung (Pflicht):
```bash
1. ‚úÖ backend/src/modules/[module]/ - Kompletten Ordner l√∂schen
2. ‚úÖ backend/src/app.ts - Import und register[Module]Routes() entfernen
3. ‚úÖ backend/src/app.ts - Modul aus /api/health und /api/hello Endpunkten entfernen
4. ‚úÖ Alle Tests die das Modul referenzieren l√∂schen/anpassen
5. ‚úÖ Package.json Dependencies pr√ºfen (falls modul-spezifische Packages)
```

### Frontend-Entfernung (Pflicht):
```bash
1. ‚úÖ frontend/src/modules/[module]/ - Kompletten Ordner l√∂schen
2. ‚úÖ frontend/src/App.tsx - Route "/[module]/*" komplett entfernen
3. ‚úÖ frontend/src/layouts/components/Sidebar.tsx - Navigation-Eintrag entfernen
4. ‚úÖ frontend/src/components/Dashboard.tsx - Modul-Kachel entfernen
5. ‚úÖ Alle Imports/Referenzen auf das Modul in anderen Komponenten entfernen
6. ‚úÖ CSS-Klassen pr√ºfen die modul-spezifisch waren (falls global verwendet)
```

### Dokumentations-Entfernung (KRITISCH):
```bash
1. ‚úÖ docs/modules/[module]/ - Kompletten Ordner l√∂schen
2. ‚úÖ docs/DOCUMENTATION_OVERVIEW.md - Modul-Referenzen entfernen
3. ‚úÖ docs/INTERDEPENDENCY.md - Alle Dependencies zum Modul entfernen
4. ‚úÖ docs/README.md - Modul aus Listen und Metriken entfernen
5. ‚úÖ docs/CHANGELOG.md - Eintrag √ºber Modul-Entfernung hinzuf√ºgen:
   ```markdown
   ## [Version] - [Datum]
   ### Entfernt
   - **[Module] Modul komplett entfernt**
     - Backend: Ordner, Routen, Tests
     - Frontend: Komponenten, Router, Navigation, Dashboard-Kachel
     - Dokumentation: Modul-Docs, Dependencies, Referenzen
     - Grund: [Begr√ºndung f√ºr Entfernung]
   ```
```

### Vollst√§ndigkeits-Check nach Modul-Entfernung:
```bash
‚úÖ Keine Backend-Imports/Routes mehr vorhanden?
‚úÖ Keine Frontend-Components/Routes mehr vorhanden?
‚úÖ Alle Navigation-Links entfernt?
‚úÖ Dashboard ohne Modul-Kachel?
‚úÖ Dokumentation komplett bereinigt?
‚úÖ CHANGELOG.md dokumentiert Entfernung?
‚úÖ Keine broken Links in verbleibender Dokumentation?
‚úÖ Tests laufen noch durch?
‚úÖ Frontend startet ohne Fehler?
‚úÖ Backend startet ohne Fehler?
```

### Entfernungs-Reihenfolge (Empfohlen):
```bash
1. üî¥ CHANGELOG.md - Entfernung dokumentieren (mit Begr√ºndung)
2. üîÑ Frontend - Routen, Navigation, Dashboard bereinigen
3. üîÑ Backend - Ordner, Imports, Routen entfernen
4. üìö Dokumentation - Referenzen und Dependencies bereinigen
5. ‚úÖ Tests - Vollst√§ndigkeits-Check durchf√ºhren
```

### NICHT ERLAUBT bei Modul-Entfernung:
‚ùå Modul-Ordner l√∂schen ohne Route-Bereinigung
‚ùå Backend/Frontend teilweise entfernt lassen
‚ùå Navigation-Links zu gel√∂schtem Modul
‚ùå Broken Dashboard-Kacheln
‚ùå Verwaiste Dokumentations-Referenzen
‚ùå Fehlende CHANGELOG.md Dokumentation der Entfernung
‚ùå Dependencies in INTERDEPENDENCY.md nicht bereinigt
‚ùå Tests die auf gel√∂schte Module verweisen

**Wichtig**: Eine Modul-Entfernung ist ein Breaking Change und MUSS ausf√ºhrlich in docs/CHANGELOG.md dokumentiert werden, inklusive Begr√ºndung und Auswirkungen auf andere Module.

Diese Regeln gew√§hrleisten Konsistenz, Wartbarkeit und Skalierbarkeit der CompanyAI-Architektur.
