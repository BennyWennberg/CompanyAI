# CompanyAI - Entwicklungsregeln & Standards

## 🚀 Must-Pass Checks (CI/Local)
- Run `npm run check:rules` before build/merge
- Build must pass: `npm run build` runs rule checks via prebuild
- Script `tools/verify-rules.ps1` performs automated checks and must pass

---

## 🏗️ BACKEND-ARCHITEKTUR

### Module-Standards (PFLICHT)
Befolge IMMER diese modulbasierte Struktur für `backend/src/modules/`:

```
backend/src/modules/[module-name]/
├── orchestrator.ts        # PFLICHT: API-Route-Handler
├── types.ts              # PFLICHT: TypeScript-Interfaces  
├── core/                 # OPTIONAL: Wiederverwendbare Hilfslogik
│   └── [helper-files].ts # z.B. auth.ts, utils.ts, validators.ts
└── functions/            # PFLICHT: Geschäftslogik-Funktionen
    ├── [function1].ts    # Eine Funktion pro Datei
    ├── [function2].ts    # Klare, beschreibende Namen
    └── [function3].ts    # Export von async functions
```

### Code-Templates (PFLICHT)

#### 1. types.ts - IMMER enthalten:
```typescript
// Request-Typen
export interface Create[Entity]Request { ... }
export interface Update[Entity]Request { ... }

// Entity-Typen
export interface [Entity] { 
  id: string;
  // weitere Properties
}

// Response-Typen
export interface APIResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
}
```

#### 2. orchestrator.ts - IMMER enthalten:
```typescript
import { Request, Response } from 'express';
import { AuthenticatedRequest } from '../hr/core/auth';

export class [Module]Orchestrator {
  static async handle[Action](req: AuthenticatedRequest, res: Response) {
    // Handler-Implementation
  }
}

export function register[Module]Routes(router: any) {
  // Route-Registrierung
}
```

#### 3. functions/[function].ts - Eine Funktion pro Datei:
```typescript
export async function [functionName](
  request: [Request]Type
): Promise<APIResponse<[Entity]>> {
  try {
    return { success: true, data: result, message: 'Success' };
  } catch (error) {
    return { success: false, error: 'Error', message: 'Failed' };
  }
}
```

### Integration-Requirements (PFLICHT)
1. ✅ Module MÜSSEN in `backend/src/app.ts` registriert werden
2. ✅ Import: `import { register[Module]Routes } from './modules/[module]/orchestrator';`
3. ✅ Route registrieren: `register[Module]Routes(apiRouter);`
4. ✅ Module-Liste in `/api/hello` endpoint aktualisieren
5. ✅ Alle Responses nutzen `APIResponse<T>` Format
6. ✅ Deutsche Fehlermeldungen für User, englische Error-Types für Logging
7. ✅ PowerShell-Test-Scripts erstellen

### Naming Conventions
- **Module-Namen**: `hr`, `support`, `user-management` (lowercase mit Bindestrichen)
- **API-Routen**: RESTful `/api/[module]/[entities]`
- **Funktions-Namen**: Verben verwenden (`createEmployee`, `fetchTickets`)
- **Datei-Namen**: camelCase (`createHRReport.ts`, `manageTickets.ts`)

### NICHT ERLAUBT (Backend):
❌ Module ohne `orchestrator.ts` oder `types.ts`  
❌ Geschäftslogik direkt in `orchestrator.ts`  
❌ Fehlende Error-Handling  
❌ Untypisierte API-Responses  
❌ Module, die nicht in `app.ts` registriert sind  
❌ Direkte Datenbankzugriffe ohne Abstraktionsschicht

---
## 💻 FRONTEND-ARCHITEKTUR

### Module-Standards (PFLICHT)
```
frontend/src/modules/[module]/
├── [Module]Module.tsx     # Haupt-Modul mit Router
├── pages/                # Seiten-Komponenten
│   ├── [Feature]Page.tsx
│   └── [Feature]Page.tsx
└── styles/
    └── [Module]Pages.css
```

### Code-Templates (PFLICHT)

#### 1. Modul-Router-Pattern:
```typescript
const [Module]Module: React.FC = () => {
  return (
    <div className="[module]-module">
      <Routes>
        <Route path="/" element={<Navigate to="/[module]/[default]" replace />} />
        <Route path="/[page]" element={<[Page]Page />} />
        <Route path="*" element={<Navigate to="/[module]/[default]" replace />} />
      </Routes>
    </div>
  );
};
```

#### 2. Page-Komponenten-Pattern:
```typescript
const [Page]Page: React.FC = () => {
  const [data, setData] = useState<[Entity][]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const loadData = async () => {
    try {
      const token = localStorage.getItem('authToken');
      const response = await fetch('http://localhost:5000/api/[module]/[endpoint]', {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });
      // Error-Handling...
    } catch (err) {
      setError('Verbindungsfehler zum Backend');
    }
  };

  return (
    <div className="[module]-page">
      <div className="page-header">
        <div className="page-title">
          <h1>[Title]</h1>
        </div>
      </div>
      <div className="content-section">
        {/* Content */}
      </div>
    </div>
  );
};
```

### CSS-Standards (PFLICHT)
```css
/* Basis-Layout-Klassen */
.[module]-page          # Haupt-Container
.page-header           # Header mit Titel und Actions
.page-title            # Titel-Bereich
.content-section       # Haupt-Inhalt

/* Button-Klassen */
.btn                   # Basis-Button
.btn-primary           # Haupt-Action (blau)
.btn-secondary         # Sekundär-Action (grau)

/* Status-Klassen */
.loading-state         # Loading-Zustand
.error-state           # Fehler-Zustand
.empty-state           # Leerer Zustand
```

### Integration-Requirements (PFLICHT)
1. ✅ Route in `frontend/src/App.tsx` registrieren
2. ✅ Navigation in `frontend/src/layouts/components/Sidebar.tsx` hinzufügen
3. ✅ Dashboard-Kachel in `frontend/src/components/Dashboard.tsx` erstellen
4. ✅ Loading-, Error- und Empty-States implementieren
5. ✅ Auth-Token bei allen API-Calls verwenden
6. ✅ Responsive Design testen

### Icon-Standards (PFLICHT)
**Verwende IMMER Heroicons statt Emojis im Frontend:**
```typescript
// ✅ RICHTIG - Heroicons verwenden
import { UserIcon, HomeIcon, ChartBarIcon, XMarkIcon } from '@heroicons/react/24/outline';

const ExampleComponent = () => (
  <button className="btn">
    <UserIcon className="h-5 w-5" />
    Benutzer verwalten
  </button>
);

// ❌ FALSCH - Emojis verwenden  
const BadExample = () => (
  <button className="btn">
    👥 Benutzer verwalten  // ❌ Keine Emojis!
  </button>
);
```

**Heroicons-Setup:**
1. ✅ Package installieren: `npm install @heroicons/react`
2. ✅ Import: `import { IconName } from '@heroicons/react/24/outline'` (für Outline-Style)
3. ✅ Import: `import { IconName } from '@heroicons/react/24/solid'` (für Solid-Style)
4. ✅ CSS-Klassen verwenden: `className="h-5 w-5"` für Größen
5. ✅ Konsistente Icon-Größen: `h-4 w-4` (klein), `h-5 w-5` (normal), `h-6 w-6` (groß)

**Standard-Icons für häufige Aktionen:**
- Benutzer: `UserIcon`, `UsersIcon`
- Navigation: `HomeIcon`, `ChevronRightIcon`, `Bars3Icon`
- Aktionen: `PlusIcon`, `PencilIcon`, `TrashIcon`, `XMarkIcon`
- Status: `CheckIcon`, `XMarkIcon`, `ExclamationTriangleIcon`
- Dokumente: `DocumentIcon`, `FolderIcon`, `ArchiveBoxIcon`

### NICHT ERLAUBT (Frontend):
❌ Direkte Layout-Imports in Modulen  
❌ Inline-Styles statt CSS-Klassen  
❌ API-Calls ohne Error-Handling  
❌ Fehlende Loading-States  
❌ Module ohne Router-Integration  
❌ Authentifizierung umgehen
❌ **Emojis statt Heroicons verwenden** 🚫
❌ **Inkonsistente Icon-Größen** 
❌ **Icons ohne CSS-Klassen für Sizing**

---
## 🔐 USER & PERMISSIONS SYSTEM

### Authentifizierung (PFLICHT für alle Module)
```typescript
// Backend - IMMER nutzen:
import { AuthenticatedRequest, requireAuth, requirePermission } from '../hr/core/auth';
// Für geschützte Routes: requireAuth oder requirePermission(action, resource)
// Logging: logAuthEvent(userId, action, resource)

// Frontend - IMMER nutzen:
const token = localStorage.getItem('authToken');
const headers = {
  'Authorization': `Bearer ${token}`,
  'Content-Type': 'application/json'
};
```

### Hierarchical Permissions Integration (KRITISCH - v2.1.0+)

**Bei JEDEM neuen Modul PFLICHT:**

#### 1. Backend hierarchyAnalyzer.ts erweitern:
```typescript
export const MODULE_DEFINITIONS = [
  {
    key: "[new-module]",
    name: "[Module Display Name]",
    icon: "[Icon]",
    pages: [
      {
        key: "[page1]",
        name: "[Page Display Name]",
        icon: "[Page Icon]",
        actions: [
          { key: "view", name: "Anzeigen", description: "..." },
          { key: "create", name: "Erstellen", description: "..." },
          { key: "edit", name: "Bearbeiten", description: "..." },
          { key: "delete", name: "Löschen", description: "..." }
        ],
        limits: [ // Optional
          { key: "dailyQuota", name: "Tägliche Anfragen", type: "number", defaultValue: 100 }
        ]
      }
    ]
  }
];
```

#### 2. Backend Permission-Checks (PFLICHT):
```typescript
export class [Module]Orchestrator {
  static async handle[Action](req: AuthenticatedRequest, res: Response) {
    const hasPermission = await checkHierarchicalPermission(
      req.user.id, '[module]', '[page]', '[action]'
    );
    
    if (!hasPermission) {
      return res.status(403).json({
        success: false,
        error: 'PermissionDenied',
        message: 'Keine Berechtigung für diese Aktion'
      });
    }
    // Rest der Handler-Logik...
  }
}
```

#### 3. Frontend Permission-Guards (PFLICHT):
```typescript
import { useUserPermissions } from '../../../hooks/useUserPermissions';

const [Page]Page: React.FC = () => {
  const { hasPageAccess, hasPageAction } = useUserPermissions();
  
  if (!hasPageAccess('[module]', '[page]')) {
    return (
      <div className="error-state">
        <h2>🚫 Zugriff verweigert</h2>
        <p>Sie haben keine Berechtigung für diese Seite.</p>
      </div>
    );
  }
  
  return (
    <div className="[module]-page">
      {hasPageAction('[module]', '[page]', 'create') && (
        <button className="btn btn-primary">Neu erstellen</button>
      )}
    </div>
  );
};
```

### User/Permission Integration Checkliste:

#### Backend (PFLICHT):
1. ✅ Module-Definition in `hierarchyAnalyzer.ts` hinzufügen  
2. ✅ Permission-Checks in alle `orchestrator.ts` Handler einbauen  
3. ✅ Tests für Permission-Scenarios schreiben

#### Frontend (PFLICHT):
1. ✅ `useUserPermissions` Hook in alle Pages integrieren  
2. ✅ Permission-Guards für Page-Access implementieren  
3. ✅ Feature-Guards für Actions implementieren  
4. ✅ Error-States für Permission-Denied-Scenarios

### NICHT ERLAUBT (User/Permissions):
❌ Neue Module ohne Permission-System-Integration  
❌ Frontend-Pages ohne Permission-Guards  
❌ Backend-APIs ohne hierarchische Permission-Checks  
❌ Module-Definitionen nicht in `hierarchyAnalyzer.ts` hinzugefügt  
❌ Features ohne Action-Level-Permission-Checks  
❌ Permission-System umgehen oder auf alte Auth zurückgreifen

---
## 🗂️ DATASOURCES & INTEGRATIONS

### DataSources Consumption (KRITISCH)
**Für JEDES Modul, das Daten aus `backend/src/datasources/` nutzt:**

#### Grundsätze:
- **Lesen**: Kombinierte Quelle (entra + manual) via `entraac/combined.ts`
- **Schreiben**: Ausschließlich in manuelle Quelle (`manual`). `entra` ist read-only
- **Import**: `import { getCombinedUsers, findCombinedUsers, createManualUser } from '../../datasources';`

#### Mapping-Standard:
- `displayName` → `firstName`/`lastName`
- `mail`/`userPrincipalName` → `email`
- `jobTitle` → `position`
- `department` → `department`

#### NICHT ERLAUBT:
❌ Direkte externe API-Calls (Graph) aus Modulen  
❌ Schreiben in `entra`  
❌ Umgehen der zentralen DataSources-Re-Exports

### AI/RAG Integration Rules
**Bei `backend/src/modules/ai/**` Änderungen:**
- ✅ `docs/modules/ai/API.md` für Endpunkte `/api/ai/chat`, `/api/ai/rag/*` aktualisieren
- ✅ Required ENV: `OPENAI_API_KEY`, `GEMINI_API_KEY`, `OLLAMA_URL`, `RAG_INDEX_PATH`

---

## 📚 DOKUMENTATION & WARTUNG

### Dokumentations-Policy (KRITISCH)
- ✅ Alle `.md`-Dateien MÜSSEN unter `docs/` liegen
- ✅ Erlaubte Ausnahmen: `README.md` (root), `backend/README.md`, `frontend/README.md`
- ✅ Pfadkonventionen:
  - Global: `docs/CHANGELOG.md`, `docs/INTERDEPENDENCY.md`
  - Module: `docs/modules/[module]/README.md`, `docs/modules/[module]/API.md`
  - Architektur: `docs/architecture/overview.md`

### Automatische Updates (PFLICHT)

#### Bei neuen Modulen:
1. ✅ `docs/modules/[module]/README.md` erstellen  
2. ✅ `docs/modules/[module]/API.md` erstellen  
3. ✅ `docs/modules/[module]/CHANGELOG.md` erstellen  
4. ✅ `docs/DOCUMENTATION_OVERVIEW.md` aktualisieren  
5. ✅ `docs/INTERDEPENDENCY.md` um Dependencies erweitern  
6. ✅ `docs/CHANGELOG.md` Version hinzufügen

#### Bei DataSources/Integrations (KRITISCH):
1. ✅ `docs/INTERDEPENDENCY.md` - DataSources-Dependencies erweitern  
2. ✅ `docs/INTERDEPENDENCY.md` - Environment-Variables dokumentieren  
3. ✅ `docs/INTERDEPENDENCY.md` - External-API-Dependencies hinzufügen  
4. ✅ `docs/DOCUMENTATION_OVERVIEW.md` - Integration-Architektur erweitern

#### Bei API-Änderungen:
1. ✅ `docs/modules/[module]/API.md` - Endpunkt-Dokumentation aktualisieren  
2. ✅ `docs/modules/[module]/CHANGELOG.md` - API-Changes dokumentieren

#### Bei Frontend Theme-Änderungen:
1. ✅ `frontend/.env` - Neue `VITE_*` Variablen hinzufügen  
2. ✅ `docs/INTERDEPENDENCY.md` - Frontend-Theme-Dependencies erweitern

### Documentation Gates (KRITISCH)
**Jede Änderung in `backend/src/datasources/**` oder `backend/src/modules/**` (APIs/Routes) MUSS folgende Dokumente aktualisieren:**
- `docs/INTERDEPENDENCY.md`
- `docs/DOCUMENTATION_OVERVIEW.md`
- `docs/CHANGELOG.md`
- `docs/modules/[module]/API.md` (bei Endpoint-Änderungen)
- `docs/modules/[module]/README.md` (bei Behavior-Änderungen)

---
## 🧹 MODUL LIFECYCLE

### Bei JEDEM neuen Modul (Checkliste):
1. ✅ Backend-Ordnerstruktur nach Standard erstellen  
2. ✅ Frontend-Ordnerstruktur nach Standard erstellen  
3. ✅ Backend in `app.ts` registrieren  
4. ✅ Frontend-Route in `App.tsx` registrieren  
5. ✅ Sidebar-Navigation hinzufügen  
6. ✅ Dashboard-Kachel erstellen  
7. ✅ Permission-System integrieren  
8. ✅ Vollständige Dokumentation erstellen  
9. ✅ PowerShell-Tests erweitern

### Modul-Entfernung (KRITISCH):
**ALLE Abhängigkeiten MÜSSEN systematisch entfernt werden:**

#### Backend-Entfernung:
1. ✅ `backend/src/modules/[module]/` - Ordner löschen  
2. ✅ `backend/src/app.ts` - Import und Routes entfernen  
3. ✅ `/api/hello` endpoint aktualisieren

#### Frontend-Entfernung:
1. ✅ `frontend/src/modules/[module]/` - Ordner löschen  
2. ✅ `frontend/src/App.tsx` - Route entfernen  
3. ✅ `frontend/src/layouts/components/Sidebar.tsx` - Navigation entfernen  
4. ✅ `frontend/src/components/Dashboard.tsx` - Kachel entfernen

#### Dokumentations-Entfernung:
1. ✅ `docs/modules/[module]/` - Ordner löschen  
2. ✅ `docs/DOCUMENTATION_OVERVIEW.md` - Referenzen entfernen  
3. ✅ `docs/INTERDEPENDENCY.md` - Dependencies entfernen  
4. ✅ `docs/CHANGELOG.md` - Entfernung dokumentieren

---
## ⚙️ TECHNICAL STANDARDS

### Dependency Hygiene
- ✅ Backend: `@types/*` packages in `devDependencies` only
- ✅ Frontend: `react-router-dom` v6.x (nicht v7 ohne Migration)
- ✅ Remove unused packages; add missing ones

### PowerShell Kompatibilität  
- ✅ Bevorzuge `;` statt `&&` in npm scripts
- ✅ Erstelle `.ps1` Scripts für Module-spezifische Tasks
- ✅ PowerShell-freundliche Pfade verwenden

### Testing Standards
- ✅ Test-Funktionen in orchestrator für jedes Modul
- ✅ PowerShell-Test-Scripts erstellen  
- ✅ Mock-Daten für Entwicklung bereitstellen

---
**Wichtig**: Diese Regeln gewährleisten Konsistenz, Wartbarkeit und Skalierbarkeit der CompanyAI-Architektur. Alle neuen Module MÜSSEN das hierarchische Permission-System ab v2.1.0 nutzen.






## Bei JEDEM neuen Modul:
1. ✅ Ordnerstruktur nach Standard erstellen
2. ✅ types.ts mit allen nötigen Interfaces
3. ✅ functions/ mit separaten Funktionsdateien  
4. ✅ orchestrator.ts mit Route-Handlern
5. ✅ Integration in index.ts
6. ✅ Vollständige Dokumentation erstellen:
   - docs/modules/[module]/README.md
   - docs/modules/[module]/API.md
   - docs/modules/[module]/CHANGELOG.md
7. ✅ **KRITISCH: Dokumentations-Wartung**
   - docs/DOCUMENTATION_OVERVIEW.md erweitern
   - docs/INTERDEPENDENCY.md um Dependencies erweitern
   - docs/README.md Module-Liste aktualisieren
   - docs/CHANGELOG.md Version hinzufügen
8. ✅ Test-Script erweitern
9. ✅ Haupt-Dokumentation aktualisieren

## Bei JEDER neuen DataSource/Integration:
1. ✅ Ordnerstruktur in `backend/src/datasources/[source]/` erstellen
2. ✅ Types, Store, Client/Sync-Logik implementieren
3. ✅ API-Routes in `backend/src/app.ts` registrieren
4. ✅ .env Variablen hinzufügen und dokumentieren
5. ✅ **KRITISCH: INTERDEPENDENCY.md aktualisieren**
   - DataSources-Dependencies-Sektion erweitern
   - Environment-Variables (.env) dokumentieren
   - External-API-Dependencies hinzufügen
   - Frontend-API-Bindings dokumentieren
   - Cross-DataSource Dependencies dokumentieren
6. ✅ `docs/DOCUMENTATION_OVERVIEW.md` erweitern
7. ✅ `docs/CHANGELOG.md` aktualisieren
8. ✅ Frontend-Integration planen und dokumentieren

## Neue Module – Verbindliche Backend-/Frontend-Integration (KRITISCH)

### Backend (Pflicht)
- Ordner: `backend/src/modules/[module]/` mit Struktur gemäß Modulstandards (siehe oben)
- Routen-Registrierung: `register[Module]Routes(apiRouter)` in `backend/src/app.ts` hinzufügen
- Auth: `requireAuth`/`requirePermission` konsequent verwenden
- Health/Hello: Endpunkt-Liste in `/api/hello` um Modul ergänzen (Beschreibung + Endpunkte)
- Tests: Mindestens Health-/Routing-Test für neues Modul

### Frontend (Pflicht)
- Ordner: `frontend/src/modules/[module]/` mit:
  - `[Module]Module.tsx` (interner Router gemäß Standard)
  - `pages/` (mind. eine Page-Komponente)
  - `styles/[Module]Pages.css`
- Router: In `frontend/src/App.tsx` Route für das Modul registrieren:
  - `<Route path="/[module]/*" element={<MainLayout><[Module]Module /></MainLayout>} />` (mit `RequireAuth` Wrapper)
- Navigation (Pflicht): In `frontend/src/layouts/components/Sidebar.tsx` Navigations-Eintrag hinzufügen (inkl. Submenu, falls zutreffend)
- UI-Standards: Vorhandene CSS-Klassen verwenden (page-header, content-section, etc.)

### Page-Struktur je Modul (Pflicht)
- Für JEDES fachliche Feature im Modul MUSS eine eigene Page-Komponente angelegt werden:
  - `frontend/src/modules/[module]/pages/[Feature]Page.tsx`
  - Beispiele: `EmployeesPage.tsx`, `OnboardingPage.tsx`, `ReportsPage.tsx`, `StatsPage.tsx`
- Der Modul-Router MUSS alle Feature-Pages per Route erreichbar machen:
  - `/[module]/[feature]` → rendert die korrekte `[Feature]Page`
- Die Sidebar MUSS ein Submenu mit Einträgen für alle Feature-Pages enthalten
- Jede neue Page MUSS Loading-, Error- und Empty-States gemäß Standard implementieren und die Auth-Header bei API-Calls verwenden

### Dashboard-Integration (Pflicht)
- `frontend/src/components/Dashboard.tsx` um eine Modul-Kachel/-Sektion erweitern:
  - Titel: Modulname (Icon optional)
  - Kurzbeschreibung (1–2 Sätze)
  - Link/Action: Button zur Modul-Startseite (`/[module]`)
  - Optional: einfache Kennzahlen (falls verfügbar)
- Kachel-Layout, Klassen und Stil gemäß bestehenden Dashboard-Karten verwenden.

### Dokumentation & Scripte (Pflicht)
- `docs/modules/[module]/` erstellen (README.md, API.md, CHANGELOG.md)
- `docs/DOCUMENTATION_OVERVIEW.md` und `docs/INTERDEPENDENCY.md` um neues Modul und Abhängigkeiten ergänzen
- PowerShell-Skripte anpassen (Tests/Checks), falls relevant

Hinweis: Module ohne vollständige Backend-Registrierung, Frontend-Router-Integration und Sidebar-Navigation werden nicht angenommen. Für jedes neue Modul müssen die Routen in `App.tsx` registriert und passende Navigationseinträge in `Sidebar.tsx` ergänzt werden.

Zusätzlich ist die Dashboard-Integration Pflicht: Für jedes neue Modul muss eine Kachel im Dashboard vorhanden sein, die zur Route `/[module]` führt und das Modul kurz beschreibt.

## Frontend-Standards (React + TypeScript)

### Frontend-Modulstruktur - Befolge IMMER:
```
frontend/src/
├── layouts/                    # Layout-Komponenten (wiederverwendbar)
│   ├── MainLayout.tsx         # Haupt-Layout mit Header + Sidebar
│   ├── AuthLayout.tsx         # Login/Auth-Layout
│   └── components/
│       ├── Header.tsx         # Globaler Header
│       └── Sidebar.tsx        # Navigation-Sidebar
├── modules/                   # Modulbasierte Komponenten
│   ├── [module]/
│   │   ├── [Module]Module.tsx # Haupt-Modul mit Router
│   │   ├── pages/            # Seiten-Komponenten
│   │   │   ├── [Page]Page.tsx
│   │   │   └── [Page]Page.tsx
│   │   └── styles/
│   │       └── [Module]Pages.css
│   └── auth/
│       └── LoginPage.tsx
├── components/                # Globale UI-Komponenten
│   ├── Dashboard.tsx
│   └── [Component].tsx
└── App.tsx                   # Router-Konfiguration
```

### Frontend-Datei-Standards:

#### 1. Modul-Router-Pattern:
```typescript
// [Module]Module.tsx - IMMER diese Struktur
import React from 'react';
import { Routes, Route, Navigate } from 'react-router-dom';
import [Page]Page from './pages/[Page]Page';

const [Module]Module: React.FC = () => {
  return (
    <div className="[module]-module">
      <Routes>
        <Route path="/" element={<Navigate to="/[module]/[default]" replace />} />
        <Route path="/[page]" element={<[Page]Page />} />
        <Route path="*" element={<Navigate to="/[module]/[default]" replace />} />
      </Routes>
    </div>
  );
};

export default [Module]Module;
```

#### 2. Page-Komponenten-Pattern:
```typescript
// pages/[Page]Page.tsx - IMMER diese Struktur
import React, { useState, useEffect } from 'react';
import '../styles/[Module]Pages.css';

interface [Entity] {
  id: string;
  // weitere Properties
}

const [Page]Page: React.FC = () => {
  const [data, setData] = useState<[Entity][]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    loadData();
  }, []);

  const loadData = async () => {
    try {
      setLoading(true);
      setError(null);

      const token = localStorage.getItem('authToken');
      const response = await fetch('http://localhost:5000/api/[module]/[endpoint]', {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });

      const result = await response.json();
      if (result.success && result.data) {
        setData(result.data.data || result.data);
      } else {
        setError(result.message || 'Fehler beim Laden');
      }
    } catch (err) {
      setError('Verbindungsfehler zum Backend');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="[module]-page">
      <div className="page-header">
        <div className="page-title">
          <h1>[Icon] [Title]</h1>
          <p>[Description]</p>
        </div>
        <div className="page-actions">
          <button className="btn btn-primary">
            [Action]
          </button>
        </div>
      </div>

      <div className="content-section">
        {/* Content hier */}
      </div>
    </div>
  );
};

export default [Page]Page;
```

#### 3. CSS-Standards - Folge IMMER diesen Klassen:
```css
/* Basis-Layout-Klassen */
.[module]-page          # Haupt-Container
.page-header           # Header mit Titel und Actions
.page-title            # Titel-Bereich
.page-actions          # Button-Bereich
.content-section       # Haupt-Inhalt
.filters-section       # Filter-Bereich
.page-summary          # Zusammenfassung unten

/* Button-Klassen */
.btn                   # Basis-Button
.btn-primary           # Haupt-Action (blau)
.btn-secondary         # Sekundär-Action (grau)
.btn-success           # Erfolg-Action (grün)
.btn-small             # Kleine Buttons
.btn-outline           # Umrandete Buttons

/* Status-Klassen */
.loading-state         # Loading-Zustand
.error-state           # Fehler-Zustand
.empty-state           # Leerer Zustand

/* Layout-Modi */
.main-layout.fullwidth # Vollbild-Layout
.main-layout.compact   # Kompaktes Layout
```

### API-Integration-Standards:

#### 1. Authentifizierung - IMMER verwenden:
```typescript
const token = localStorage.getItem('authToken');
const headers = {
  'Authorization': `Bearer ${token}`,
  'Content-Type': 'application/json'
};
```

#### 2. Error-Handling - IMMER implementieren:
```typescript
try {
  // API-Call
} catch (err) {
  setError('Verbindungsfehler zum Backend');
  console.error('Fehler beim [Action]:', err);
}
```

#### 3. Loading-States - IMMER verwenden:
```typescript
const [loading, setLoading] = useState(true);

// In JSX:
{loading && (
  <div className="loading-state">
    <div className="loading-spinner"></div>
    <p>Lade [Data]...</p>
  </div>
)}
```

### Router-Integration-Standards:

#### 1. App.tsx - Router-Struktur:
```typescript
// IMMER diese Router-Struktur befolgen
<Router>
  <Routes>
    <Route path="/login" element={
      <AuthLayout><LoginPage /></AuthLayout>
    } />
    <Route path="/[module]/*" element={
      <MainLayout><[Module]Module /></MainLayout>
    } />
    <Route path="*" element={<Navigate to="/" replace />} />
  </Routes>
</Router>
```

#### 2. Layout-Integration - Module nutzen Layouts automatisch:
```typescript
// Layout wird durch Router bereitgestellt, nicht direkt importiert
// Module erhalten Layout-Context automatisch
```

### State-Management-Standards:

#### 1. Lokaler State für Seiten-Daten:
```typescript
const [data, setData] = useState<Type[]>([]);
const [loading, setLoading] = useState(true);
const [error, setError] = useState<string | null>(null);
const [filters, setFilters] = useState({ /* filter object */ });
```

#### 2. localStorage für User-Daten:
```typescript
// Authentifizierung
localStorage.getItem('authToken')
localStorage.getItem('userRole')
localStorage.getItem('userName')
```

### Naming-Conventions Frontend:

#### Komponenten:
- PascalCase: `EmployeesPage.tsx`, `HeaderComponent.tsx`
- Seiten enden mit `Page`: `EmployeesPage`, `DashboardPage`
- Module enden mit `Module`: `HRModule`, `SupportModule`

#### CSS-Klassen:
- kebab-case: `.employee-card`, `.ticket-list`
- Modul-Präfix: `.hr-page`, `.support-module`
- Status-Präfix: `.status-active`, `.priority-high`

#### Dateien:
- Komponenten: PascalCase.tsx
- Styles: PascalCase.css oder kebab-case.css
- Module-Ordner: lowercase mit Bindestrich

## Frontend-Integration-Checkliste:

### Bei JEDEM neuen Frontend-Modul:
1. ✅ Modul-Ordner in `src/modules/[module]/` erstellen
2. ✅ `[Module]Module.tsx` mit Router-Setup
3. ✅ `pages/` Ordner mit mindestens einer Seite
4. ✅ `styles/[Module]Pages.css` für Modul-Styles
5. ✅ Integration in `App.tsx` Router
6. ✅ Navigation in `Sidebar.tsx` hinzufügen
7. ✅ API-Integration mit Backend-Endpunkten
8. ✅ Error-Handling und Loading-States
9. ✅ Responsive Design testen
10. ✅ **KRITISCH: Dokumentations-Wartung**
    - docs/DOCUMENTATION_OVERVIEW.md um Frontend-Inhalte erweitern
    - docs/INTERDEPENDENCY.md um Frontend-Dependencies erweitern
    - docs/modules/[module]/README.md um Frontend-Sektion erweitern
    - docs/README.md Frontend-Features aktualisieren

## Frontend NICHT ERLAUBT:
❌ Direkte Layout-Imports in Modulen
❌ Inline-Styles statt CSS-Klassen
❌ API-Calls ohne Error-Handling
❌ Fehlende Loading-States
❌ Untypisierte Komponenten-Props
❌ Fehlende Responsive-Design
❌ Module ohne Router-Integration
❌ Authentifizierung umgehen
❌ Frontend-Module ohne Dokumentations-Updates
❌ Neue Pages ohne INTERDEPENDENCY.md Dependencies-Update
❌ CSS-Änderungen ohne Shared-Component-Dokumentation

## Modul-Entfernung und Löschung (KRITISCH)

Wenn ein Modul entfernt oder gelöscht werden soll, MÜSSEN ALLE Abhängigkeiten systematisch entfernt werden:

### Backend-Entfernung (Pflicht):
```bash
1. ✅ backend/src/modules/[module]/ - Kompletten Ordner löschen
2. ✅ backend/src/app.ts - Import und register[Module]Routes() entfernen
3. ✅ backend/src/app.ts - Modul aus /api/health und /api/hello Endpunkten entfernen
4. ✅ Alle Tests die das Modul referenzieren löschen/anpassen
5. ✅ Package.json Dependencies prüfen (falls modul-spezifische Packages)
```

### Frontend-Entfernung (Pflicht):
```bash
1. ✅ frontend/src/modules/[module]/ - Kompletten Ordner löschen
2. ✅ frontend/src/App.tsx - Route "/[module]/*" komplett entfernen
3. ✅ frontend/src/layouts/components/Sidebar.tsx - Navigation-Eintrag entfernen
4. ✅ frontend/src/components/Dashboard.tsx - Modul-Kachel entfernen
5. ✅ Alle Imports/Referenzen auf das Modul in anderen Komponenten entfernen
6. ✅ CSS-Klassen prüfen die modul-spezifisch waren (falls global verwendet)
```

### Dokumentations-Entfernung (KRITISCH):
```bash
1. ✅ docs/modules/[module]/ - Kompletten Ordner löschen
2. ✅ docs/DOCUMENTATION_OVERVIEW.md - Modul-Referenzen entfernen
3. ✅ docs/INTERDEPENDENCY.md - Alle Dependencies zum Modul entfernen
4. ✅ docs/README.md - Modul aus Listen und Metriken entfernen
5. ✅ docs/CHANGELOG.md - Eintrag über Modul-Entfernung hinzufügen:
   ```markdown
   ## [Version] - [Datum]
   ### Entfernt
   - **[Module] Modul komplett entfernt**
     - Backend: Ordner, Routen, Tests
     - Frontend: Komponenten, Router, Navigation, Dashboard-Kachel
     - Dokumentation: Modul-Docs, Dependencies, Referenzen
     - Grund: [Begründung für Entfernung]
   ```
```

### Vollständigkeits-Check nach Modul-Entfernung:
```bash
✅ Keine Backend-Imports/Routes mehr vorhanden?
✅ Keine Frontend-Components/Routes mehr vorhanden?
✅ Alle Navigation-Links entfernt?
✅ Dashboard ohne Modul-Kachel?
✅ Dokumentation komplett bereinigt?
✅ CHANGELOG.md dokumentiert Entfernung?
✅ Keine broken Links in verbleibender Dokumentation?
✅ Tests laufen noch durch?
✅ Frontend startet ohne Fehler?
✅ Backend startet ohne Fehler?
```

### Entfernungs-Reihenfolge (Empfohlen):
```bash
1. 🔴 CHANGELOG.md - Entfernung dokumentieren (mit Begründung)
2. 🔄 Frontend - Routen, Navigation, Dashboard bereinigen
3. 🔄 Backend - Ordner, Imports, Routen entfernen
4. 📚 Dokumentation - Referenzen und Dependencies bereinigen
5. ✅ Tests - Vollständigkeits-Check durchführen
```

### NICHT ERLAUBT bei Modul-Entfernung:
❌ Modul-Ordner löschen ohne Route-Bereinigung
❌ Backend/Frontend teilweise entfernt lassen
❌ Navigation-Links zu gelöschtem Modul
❌ Broken Dashboard-Kacheln
❌ Verwaiste Dokumentations-Referenzen
❌ Fehlende CHANGELOG.md Dokumentation der Entfernung
❌ Dependencies in INTERDEPENDENCY.md nicht bereinigt
❌ Tests die auf gelöschte Module verweisen

**Wichtig**: Eine Modul-Entfernung ist ein Breaking Change und MUSS ausführlich in docs/CHANGELOG.md dokumentiert werden, inklusive Begründung und Auswirkungen auf andere Module.

## Hierarchical Permissions Integration (KRITISCH - NEU v2.1.0)

Bei JEDEM neuen Modul MUSS die Integration in das hierarchische Permission-System berücksichtigt werden:

### Modul-Permission-Definition (PFLICHT):
```bash
1. ✅ Modul-Schlüssel definieren (z.B. "analytics", "reporting", "inventory")
2. ✅ Page-Definitionen mit Actions erstellen:
   - Page-Keys: beschreibende Namen (z.B. "reports", "dashboards", "export")
   - Actions: view, create, edit, delete, export, import, etc.
   - Limits (optional): dailyQuota, maxRecords, etc.
3. ✅ Modul-spezifische Permission-Logik implementieren
4. ✅ Backend-Permission-Checks in orchestrator.ts-Handlern
5. ✅ Frontend-Permission-Guards für Pages und Features
```

### Backend-Integration mit Permission-System:
```typescript
// orchestrator.ts - IMMER Permission-Checks einbauen
import { AuthenticatedRequest, requirePermission } from '../hr/core/auth';

export class [Module]Orchestrator {
  static async handle[Action](req: AuthenticatedRequest, res: Response) {
    // Permission-Check für hierarchisches System
    const hasPermission = await checkHierarchicalPermission(
      req.user.id, 
      '[module]', 
      '[page]', 
      '[action]'
    );
    
    if (!hasPermission) {
      return res.status(403).json({
        success: false,
        error: 'PermissionDenied',
        message: 'Keine Berechtigung für diese Aktion'
      });
    }
    
    // Rest der Handler-Logik...
  }
}
```

### Frontend-Permission-Guards:
```typescript
// pages/[Page]Page.tsx - Permission-Guards implementieren
import { useUserPermissions } from '../../../hooks/useUserPermissions';

const [Page]Page: React.FC = () => {
  const { hasPageAccess, hasPageAction } = useUserPermissions();
  
  // Page-Level Guard
  if (!hasPageAccess('[module]', '[page]')) {
    return (
      <div className="error-state">
        <h2>🚫 Zugriff verweigert</h2>
        <p>Sie haben keine Berechtigung für diese Seite.</p>
      </div>
    );
  }
  
  // Feature-Level Guards im JSX
  return (
    <div className="[module]-page">
      {/* Conditional Features basierend auf Permissions */}
      {hasPageAction('[module]', '[page]', 'create') && (
        <button className="btn btn-primary">Neu erstellen</button>
      )}
      {hasPageAction('[module]', '[page]', 'export') && (
        <button className="btn btn-secondary">Exportieren</button>
      )}
    </div>
  );
};
```

### hierarchyAnalyzer.ts erweitern (Backend):
```typescript
// Neue Module müssen in die Modul-Definitionen eingepflegt werden
export const MODULE_DEFINITIONS = [
  {
    key: "hr",
    name: "HR", 
    icon: "👥",
    pages: [...]
  },
  {
    key: "[new-module]",
    name: "[Module Display Name]",
    icon: "[Icon]",
    pages: [
      {
        key: "[page1]",
        name: "[Page Display Name]",
        icon: "[Page Icon]",
        actions: [
          { key: "view", name: "Anzeigen", description: "..." },
          { key: "create", name: "Erstellen", description: "..." },
          { key: "edit", name: "Bearbeiten", description: "..." },
          { key: "delete", name: "Löschen", description: "..." }
        ],
        limits: [ // Optional
          { key: "dailyQuota", name: "Tägliche Anfragen", type: "number", defaultValue: 100 }
        ]
      }
    ]
  }
];
```

### Permission-System-Integration-Checkliste (PFLICHT):

#### Bei JEDEM neuen Backend-Modul:
```bash
1. ✅ Module-Definition in hierarchyAnalyzer.ts hinzufügen (Modul + Pages + Actions)
2. ✅ Permission-Checks in alle orchestrator.ts Handler einbauen
3. ✅ Modul-spezifische Permission-Logic implementieren (falls nötig)
4. ✅ API-Endpunkte für Permission-Management erweitern (falls nötig)
5. ✅ Tests für Permission-Scenarios schreiben
```

#### Bei JEDEM neuen Frontend-Modul:
```bash
1. ✅ useUserPermissions Hook in alle Pages integrieren
2. ✅ Permission-Guards für Page-Access implementieren
3. ✅ Feature-Guards für Actions implementieren (Create/Edit/Delete buttons)
4. ✅ Conditional UI basierend auf User-Permissions
5. ✅ Error-States für Permission-Denied-Scenarios
6. ✅ Loading-States während Permission-Checks
```

#### Dokumentations-Updates (KRITISCH):
```bash
1. ✅ docs/modules/[module]/README.md - Permission-Sektion hinzufügen:
   - Welche Permissions das Modul nutzt
   - Hierarchische Integration (Department/SubGroup/Individual)
   - Permission-Dependencies zu anderen Modulen
2. ✅ docs/modules/[module]/API.md - Permission-Requirements dokumentieren:
   - Welche Permission für welchen Endpoint erforderlich
   - Hierarchische Permission-Checks beschreiben
   - Error-Responses bei Permission-Denied
3. ✅ docs/INTERDEPENDENCY.md - Permission-Dependencies ergänzen:
   - Modul-spezifische Permission-Integration
   - Cross-Module-Permission-Dependencies
   - Hierarchical Permission System Integration
4. ✅ docs/DOCUMENTATION_OVERVIEW.md - Permission-Dokumentation erweitern
5. ✅ docs/CHANGELOG.md - Neue Permission-Integration dokumentieren
```

### NICHT ERLAUBT (Hard-Fails):
❌ Neue Module ohne Permission-System-Integration
❌ Frontend-Pages ohne Permission-Guards  
❌ Backend-APIs ohne hierarchische Permission-Checks
❌ Module-Definitionen nicht in hierarchyAnalyzer.ts hinzugefügt
❌ Permission-Integration ohne Dokumentations-Update
❌ Features ohne Action-Level-Permission-Checks
❌ Permission-System umgehen oder direkt auf alte Auth zurückgreifen
❌ Neue Module ohne Permission-Test-Scenarios

### Beispiel-Integration neues "Analytics"-Modul:

#### 1. Backend hierarchyAnalyzer.ts erweitern:
```typescript
{
  key: "analytics",
  name: "Analytics", 
  icon: "📊",
  pages: [
    {
      key: "reports",
      name: "Berichte",
      icon: "📈",
      actions: [
        { key: "view", name: "Anzeigen", description: "Berichte anzeigen" },
        { key: "create", name: "Erstellen", description: "Neue Berichte erstellen" },
        { key: "export", name: "Exportieren", description: "Berichte exportieren" },
        { key: "delete", name: "Löschen", description: "Berichte löschen" }
      ],
      limits: [
        { key: "monthlyReports", name: "Berichte pro Monat", type: "number", defaultValue: 10 }
      ]
    }
  ]
}
```

#### 2. Backend orchestrator.ts mit Permission-Checks:
```typescript
static async handleGetReports(req: AuthenticatedRequest, res: Response) {
  const hasPermission = await checkHierarchicalPermission(
    req.user.id, 'analytics', 'reports', 'view'
  );
  
  if (!hasPermission) {
    return res.status(403).json({
      success: false,
      error: 'PermissionDenied',
      message: 'Keine Berechtigung um Analytics-Berichte zu sehen'
    });
  }
  
  // Rest der Logic...
}
```

#### 3. Frontend Permission-Guards:
```typescript
const ReportsPage: React.FC = () => {
  const { hasPageAccess, hasPageAction } = useUserPermissions();
  
  if (!hasPageAccess('analytics', 'reports')) {
    return <PermissionDenied />;
  }
  
  return (
    <div className="analytics-page">
      <div className="page-actions">
        {hasPageAction('analytics', 'reports', 'create') && (
          <button>Neuen Bericht erstellen</button>
        )}
        {hasPageAction('analytics', 'reports', 'export') && (
          <button>Exportieren</button>
        )}
      </div>
    </div>
  );
};
```

### Migration bestehender Module:

Bestehende Module MÜSSEN schrittweise in das hierarchische Permission-System integriert werden:

```bash
1. ✅ Modul-Definition hinzufügen (hierarchyAnalyzer.ts)
2. ✅ Permission-Checks schrittweise in Backend einbauen
3. ✅ Frontend-Guards schrittweise hinzufügen  
4. ✅ Dokumentation aktualisieren
5. ✅ Tests erweitern
6. ✅ Migration in CHANGELOG.md dokumentieren
```

**Wichtig**: Das hierarchische Permission-System ist ab v2.1.0 der neue Standard. Alle neuen Module MÜSSEN dieses System von Anfang an nutzen. Bestehende Module müssen sukzessive migriert werden.

Diese Regeln gewährleisten Konsistenz, Wartbarkeit und Skalierbarkeit der CompanyAI-Architektur.

---

## 🔄 INTELLIGENTE RULE-EVOLUTION & STRUKTURSCHUTZ

### 📁 PROJEKTSTRUKTUR-SCHUTZ (KRITISCH)

#### Bestehende CompanyAI-Struktur MUSS beibehalten werden:
```
CompanyAI/
├── backend/src/
│   ├── modules/               # ✅ Modulare Architektur beibehalten
│   │   ├── [module]/
│   │   │   ├── orchestrator.ts    # ✅ PFLICHT für API-Handler
│   │   │   ├── types.ts           # ✅ PFLICHT für Interfaces  
│   │   │   ├── core/              # ✅ Business Logic
│   │   │   ├── functions/         # ✅ Spezifische Funktionen
│   │   │   └── README.md         # ✅ Dokumentation
│   ├── services/             # ✅ Shared Services (auth.service.ts etc.)
│   ├── datasources/          # ✅ Datenquellen (entraac, ldap etc.)
│   └── utils/               # ✅ Utilities
├── frontend/src/
│   ├── modules/             # ✅ Frontend-Module spiegeln Backend
│   │   ├── [module]/
│   │   │   ├── pages/           # ✅ React-Komponenten
│   │   │   ├── components/      # ✅ Wiederverwendbare Komponenten  
│   │   │   └── [Module].tsx     # ✅ Haupt-Modul-Komponente
│   ├── context/             # ✅ React Contexts (PermissionContext etc.)
│   ├── layouts/             # ✅ Layout-Komponenten
│   └── components/          # ✅ Globale Komponenten
└── admin-data/              # ✅ JSON-basierte Datenspeicherung
    ├── department-permissions.json
    └── databases/
```

### 🚨 VERBOTEN: Struktur-Breaking Changes
- ❌ Neue Top-Level-Ordner ohne Genehmigung
- ❌ Orchestrator-Pattern umgehen (`orchestrator.ts` ist Pflicht)
- ❌ Module außerhalb von `modules/` erstellen
- ❌ Direct Database-Zugriff (nur über Services)
- ❌ Hardcoded Paths ändern

---

## 🤔 RULE-EXCEPTION & EVOLUTION-SYSTEM

### Wenn du eine SINNVOLLE Änderung machst, die gegen Rules verstößt:

#### SCHRITT 1: Exception-Request erstellen
```markdown
<!-- RULE-EXCEPTION-REQUEST -->
## 📋 Rule-Verstoß-Begründung

**Verstoßene Rule:** [Welche Rule wird verletzt?]
**Grund:** [Warum ist diese Änderung sinnvoll?]
**Auswirkungen:** [Was ändert sich?]
**Vorteile:** [Welche Verbesserungen bringt das?]
**Rückwärts-Kompatibilität:** [Bleibt alles funktional?]

### Beispiel:
**Verstoßene Rule:** "Keine neuen Top-Level-Ordner"
**Grund:** "Neuer 'integrations/' Ordner für externe API-Verbindungen"
**Auswirkungen:** "Bessere Trennung von Core-Logik und Integrationen"
**Vorteile:** "Klarere Architektur, einfachere Wartung"
**Rückwärts-Kompatibilität:** "Ja, bestehende Module unverändert"
```

#### SCHRITT 2: Frage um Genehmigung
```
🤔 RULE-EXCEPTION-REQUEST: Darf ich [BESCHREIBUNG] machen?
Grund: [KURZE BEGRÜNDUNG]
```

#### SCHRITT 3: Bei Genehmigung → Rule-Update
Nach Genehmigung MUSS diese Rule aktualisiert werden mit:
```markdown
### ✅ NEUE REGEL (Akzeptierte Exception vom DD.MM.YYYY)
- [Beschreibung der neuen erlaubten Praxis]
- [Begründung warum es jetzt erlaubt ist]
```

---

## 🔍 KONSISTENZ-CHECKS & QUALITÄTSSICHERUNG

### Backend-Modul Vollständigkeits-Check:
```bash
# Jedes neue Backend-Modul MUSS haben:
backend/src/modules/[module]/
├── orchestrator.ts     # ✅ API-Handler
├── types.ts           # ✅ TypeScript Interfaces
├── core/              # ✅ Business Logic
└── README.md          # ✅ Dokumentation
```

### Frontend-Modul Vollständigkeits-Check:
```bash
# Jedes neue Frontend-Modul MUSS haben:
frontend/src/modules/[module]/
├── [Module].tsx       # ✅ Haupt-Komponente
├── pages/             # ✅ Route-Komponenten
└── components/        # ✅ Wiederverwendbare Komponenten
```

### API-Consistency Check:
```typescript
// Alle API-Responses MÜSSEN diese Struktur haben:
{
  success: boolean,
  data?: any,
  error?: string,
  message?: string
}
```

### Permission-System Consistency:
```typescript
// Alle geschützten Routes MÜSSEN:
router.post('/api/[module]/[endpoint]', 
  requireAuth,                    # ✅ Authentication  
  requirePermission('action', 'resource'), # ✅ Authorization
  ModuleOrchestrator.handleMethod # ✅ Handler
);
```

---

## 🛡️ SECURITY & STABILITY GUARDS

### Kritische Files - Extra Vorsicht:
```
backend/src/services/auth.service.ts      # 🔐 Authentication Core
backend/src/modules/hr/core/auth.ts       # 🔐 Authorization Logic  
frontend/src/context/PermissionContext.tsx # 🔐 Permission Management
backend/admin-data/department-permissions.json # 📊 Permission Data
frontend/src/App.tsx                      # 🏗️ App Architecture
backend/src/app.ts                       # 🏗️ Backend Architecture
```

### Vor Änderungen an kritischen Files:
1. **Backup erstellen** (Copy des Files)
2. **Änderungen dokumentieren** (Was, Warum, Auswirkungen)
3. **Testen** nach jeder Änderung
4. **Rollback-Plan** haben

### 🚫 AUTOMATISCH GENERIERTE DATEIEN - BEARBEITUNG VERBOTEN:
Diese Dateien werden automatisch vom System generiert und dürfen NIEMALS manuell bearbeitet werden:
```
backend/admin-data/department-permissions.json  # Auto-Generated durch EISBÄR-POPULATION
```

**Warum verboten:**
- Werden bei jedem Server-Neustart automatisch regeneriert
- Manuelle Änderungen gehen verloren
- Können das Auto-Population-System beschädigen
- Enthalten automatisch berechnete Berechtigungsstrukturen

**Was stattdessen tun:**
- Änderungen in den Quell-Algorithmen vornehmen (EISBÄR-POPULATION System)
- Backend neustart lässt Auto-Population laufen
- Berechtigungen über Admin-Portal UI verwalten

---

## 📝 DEVELOPMENT WORKFLOW

### Bei neuen Features:
1. **Prüfe bestehende Struktur** - Passt es ins Modul-System?
2. **Folge Namenskonventionen** - camelCase, kebab-case etc.
3. **Implementiere Permission-Checks** - Wer darf was?
4. **Dokumentiere Änderungen** - README.md updaten
5. **Teste alle Benutzer-Rollen** - Admin, User, Test-User

### Bei Struktur-Änderungen:
1. **Rule-Exception-Request** stellen
2. **Auf Genehmigung warten**
3. **Bei Genehmigung: Rules updaten**
4. **Änderungen implementieren**
5. **Dokumentation anpassen**

Diese intelligenten Rules schützen die CompanyAI-Architektur und ermöglichen gleichzeitig sinnvolle Evolution.