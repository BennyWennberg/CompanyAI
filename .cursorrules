# CompanyAI - Entwicklungsregeln & Standards

## üöÄ Must-Pass Checks (CI/Local)
- Run `npm run check:rules` before build/merge
- Build must pass: `npm run build` runs rule checks via prebuild
- Script `tools/verify-rules.ps1` performs automated checks and must pass

---

## üèóÔ∏è BACKEND-ARCHITEKTUR

### Module-Standards (PFLICHT)
Befolge IMMER diese modulbasierte Struktur f√ºr `backend/src/modules/`:

```
backend/src/modules/[module-name]/
‚îú‚îÄ‚îÄ orchestrator.ts        # PFLICHT: API-Route-Handler
‚îú‚îÄ‚îÄ types.ts              # PFLICHT: TypeScript-Interfaces  
‚îú‚îÄ‚îÄ core/                 # OPTIONAL: Wiederverwendbare Hilfslogik
‚îÇ   ‚îî‚îÄ‚îÄ [helper-files].ts # z.B. auth.ts, utils.ts, validators.ts
‚îî‚îÄ‚îÄ functions/            # PFLICHT: Gesch√§ftslogik-Funktionen
    ‚îú‚îÄ‚îÄ [function1].ts    # Eine Funktion pro Datei
    ‚îú‚îÄ‚îÄ [function2].ts    # Klare, beschreibende Namen
    ‚îî‚îÄ‚îÄ [function3].ts    # Export von async functions
```

### Code-Templates (PFLICHT)

#### 1. types.ts - IMMER enthalten:
```typescript
// Request-Typen
export interface Create[Entity]Request { ... }
export interface Update[Entity]Request { ... }

// Entity-Typen
export interface [Entity] { 
  id: string;
  // weitere Properties
}

// Response-Typen
export interface APIResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
}
```

#### 2. orchestrator.ts - IMMER enthalten:
```typescript
import { Request, Response } from 'express';
import { AuthenticatedRequest } from '../hr/core/auth';

export class [Module]Orchestrator {
  static async handle[Action](req: AuthenticatedRequest, res: Response) {
    // Handler-Implementation
  }
}

export function register[Module]Routes(router: any) {
  // Route-Registrierung
}
```

#### 3. functions/[function].ts - Eine Funktion pro Datei:
```typescript
export async function [functionName](
  request: [Request]Type
): Promise<APIResponse<[Entity]>> {
  try {
    return { success: true, data: result, message: 'Success' };
  } catch (error) {
    return { success: false, error: 'Error', message: 'Failed' };
  }
}
```

### Integration-Requirements (PFLICHT)
1. ‚úÖ Module M√úSSEN in `backend/src/app.ts` registriert werden
2. ‚úÖ Import: `import { register[Module]Routes } from './modules/[module]/orchestrator';`
3. ‚úÖ Route registrieren: `register[Module]Routes(apiRouter);`
4. ‚úÖ Module-Liste in `/api/hello` endpoint aktualisieren
5. ‚úÖ Alle Responses nutzen `APIResponse<T>` Format
6. ‚úÖ Deutsche Fehlermeldungen f√ºr User, englische Error-Types f√ºr Logging
7. ‚úÖ PowerShell-Test-Scripts erstellen

### Naming Conventions
- **Module-Namen**: `hr`, `support`, `user-management` (lowercase mit Bindestrichen)
- **API-Routen**: RESTful `/api/[module]/[entities]`
- **Funktions-Namen**: Verben verwenden (`createEmployee`, `fetchTickets`)
- **Datei-Namen**: camelCase (`createHRReport.ts`, `manageTickets.ts`)

### NICHT ERLAUBT (Backend):
‚ùå Module ohne `orchestrator.ts` oder `types.ts`  
‚ùå Gesch√§ftslogik direkt in `orchestrator.ts`  
‚ùå Fehlende Error-Handling  
‚ùå Untypisierte API-Responses  
‚ùå Module, die nicht in `app.ts` registriert sind  
‚ùå Direkte Datenbankzugriffe ohne Abstraktionsschicht

---
## üíª FRONTEND-ARCHITEKTUR

### Module-Standards (PFLICHT)
```
frontend/src/modules/[module]/
‚îú‚îÄ‚îÄ [Module]Module.tsx     # Haupt-Modul mit Router
‚îú‚îÄ‚îÄ pages/                # Seiten-Komponenten
‚îÇ   ‚îú‚îÄ‚îÄ [Feature]Page.tsx
‚îÇ   ‚îî‚îÄ‚îÄ [Feature]Page.tsx
‚îî‚îÄ‚îÄ styles/
    ‚îî‚îÄ‚îÄ [Module]Pages.css
```

### Code-Templates (PFLICHT)

#### 1. Modul-Router-Pattern:
```typescript
const [Module]Module: React.FC = () => {
  return (
    <div className="[module]-module">
      <Routes>
        <Route path="/" element={<Navigate to="/[module]/[default]" replace />} />
        <Route path="/[page]" element={<[Page]Page />} />
        <Route path="*" element={<Navigate to="/[module]/[default]" replace />} />
      </Routes>
    </div>
  );
};
```

#### 2. Page-Komponenten-Pattern:
```typescript
const [Page]Page: React.FC = () => {
  const [data, setData] = useState<[Entity][]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const loadData = async () => {
    try {
      const token = localStorage.getItem('authToken');
      const response = await fetch('http://localhost:5000/api/[module]/[endpoint]', {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });
      // Error-Handling...
    } catch (err) {
      setError('Verbindungsfehler zum Backend');
    }
  };

  return (
    <div className="[module]-page">
      <div className="page-header">
        <div className="page-title">
          <h1>[Title]</h1>
        </div>
      </div>
      <div className="content-section">
        {/* Content */}
      </div>
    </div>
  );
};
```

### CSS-Standards (PFLICHT)
```css
/* Basis-Layout-Klassen */
.[module]-page          # Haupt-Container
.page-header           # Header mit Titel und Actions
.page-title            # Titel-Bereich
.content-section       # Haupt-Inhalt

/* Button-Klassen */
.btn                   # Basis-Button
.btn-primary           # Haupt-Action (blau)
.btn-secondary         # Sekund√§r-Action (grau)

/* Status-Klassen */
.loading-state         # Loading-Zustand
.error-state           # Fehler-Zustand
.empty-state           # Leerer Zustand
```

### Integration-Requirements (PFLICHT)
1. ‚úÖ Route in `frontend/src/App.tsx` registrieren
2. ‚úÖ Navigation in `frontend/src/layouts/components/Sidebar.tsx` hinzuf√ºgen
3. ‚úÖ Dashboard-Kachel in `frontend/src/components/Dashboard.tsx` erstellen
4. ‚úÖ Loading-, Error- und Empty-States implementieren
5. ‚úÖ Auth-Token bei allen API-Calls verwenden
6. ‚úÖ Responsive Design testen

### NICHT ERLAUBT (Frontend):
‚ùå Direkte Layout-Imports in Modulen  
‚ùå Inline-Styles statt CSS-Klassen  
‚ùå API-Calls ohne Error-Handling  
‚ùå Fehlende Loading-States  
‚ùå Module ohne Router-Integration  
‚ùå Authentifizierung umgehen

---
## üîê USER & PERMISSIONS SYSTEM

### Authentifizierung (PFLICHT f√ºr alle Module)
```typescript
// Backend - IMMER nutzen:
import { AuthenticatedRequest, requireAuth, requirePermission } from '../hr/core/auth';
// F√ºr gesch√ºtzte Routes: requireAuth oder requirePermission(action, resource)
// Logging: logAuthEvent(userId, action, resource)

// Frontend - IMMER nutzen:
const token = localStorage.getItem('authToken');
const headers = {
  'Authorization': `Bearer ${token}`,
  'Content-Type': 'application/json'
};
```

### Hierarchical Permissions Integration (KRITISCH - v2.1.0+)

**Bei JEDEM neuen Modul PFLICHT:**

#### 1. Backend hierarchyAnalyzer.ts erweitern:
```typescript
export const MODULE_DEFINITIONS = [
  {
    key: "[new-module]",
    name: "[Module Display Name]",
    icon: "[Icon]",
    pages: [
      {
        key: "[page1]",
        name: "[Page Display Name]",
        icon: "[Page Icon]",
        actions: [
          { key: "view", name: "Anzeigen", description: "..." },
          { key: "create", name: "Erstellen", description: "..." },
          { key: "edit", name: "Bearbeiten", description: "..." },
          { key: "delete", name: "L√∂schen", description: "..." }
        ],
        limits: [ // Optional
          { key: "dailyQuota", name: "T√§gliche Anfragen", type: "number", defaultValue: 100 }
        ]
      }
    ]
  }
];
```

#### 2. Backend Permission-Checks (PFLICHT):
```typescript
export class [Module]Orchestrator {
  static async handle[Action](req: AuthenticatedRequest, res: Response) {
    const hasPermission = await checkHierarchicalPermission(
      req.user.id, '[module]', '[page]', '[action]'
    );
    
    if (!hasPermission) {
      return res.status(403).json({
        success: false,
        error: 'PermissionDenied',
        message: 'Keine Berechtigung f√ºr diese Aktion'
      });
    }
    // Rest der Handler-Logik...
  }
}
```

#### 3. Frontend Permission-Guards (PFLICHT):
```typescript
import { useUserPermissions } from '../../../hooks/useUserPermissions';

const [Page]Page: React.FC = () => {
  const { hasPageAccess, hasPageAction } = useUserPermissions();
  
  if (!hasPageAccess('[module]', '[page]')) {
    return (
      <div className="error-state">
        <h2>üö´ Zugriff verweigert</h2>
        <p>Sie haben keine Berechtigung f√ºr diese Seite.</p>
      </div>
    );
  }
  
  return (
    <div className="[module]-page">
      {hasPageAction('[module]', '[page]', 'create') && (
        <button className="btn btn-primary">Neu erstellen</button>
      )}
    </div>
  );
};
```

### User/Permission Integration Checkliste:

#### Backend (PFLICHT):
1. ‚úÖ Module-Definition in `hierarchyAnalyzer.ts` hinzuf√ºgen  
2. ‚úÖ Permission-Checks in alle `orchestrator.ts` Handler einbauen  
3. ‚úÖ Tests f√ºr Permission-Scenarios schreiben

#### Frontend (PFLICHT):
1. ‚úÖ `useUserPermissions` Hook in alle Pages integrieren  
2. ‚úÖ Permission-Guards f√ºr Page-Access implementieren  
3. ‚úÖ Feature-Guards f√ºr Actions implementieren  
4. ‚úÖ Error-States f√ºr Permission-Denied-Scenarios

### NICHT ERLAUBT (User/Permissions):
‚ùå Neue Module ohne Permission-System-Integration  
‚ùå Frontend-Pages ohne Permission-Guards  
‚ùå Backend-APIs ohne hierarchische Permission-Checks  
‚ùå Module-Definitionen nicht in `hierarchyAnalyzer.ts` hinzugef√ºgt  
‚ùå Features ohne Action-Level-Permission-Checks  
‚ùå Permission-System umgehen oder auf alte Auth zur√ºckgreifen

---
## üóÇÔ∏è DATASOURCES & INTEGRATIONS

### DataSources Consumption (KRITISCH)
**F√ºr JEDES Modul, das Daten aus `backend/src/datasources/` nutzt:**

#### Grunds√§tze:
- **Lesen**: Kombinierte Quelle (entra + manual) via `entraac/combined.ts`
- **Schreiben**: Ausschlie√ülich in manuelle Quelle (`manual`). `entra` ist read-only
- **Import**: `import { getCombinedUsers, findCombinedUsers, createManualUser } from '../../datasources';`

#### Mapping-Standard:
- `displayName` ‚Üí `firstName`/`lastName`
- `mail`/`userPrincipalName` ‚Üí `email`
- `jobTitle` ‚Üí `position`
- `department` ‚Üí `department`

#### NICHT ERLAUBT:
‚ùå Direkte externe API-Calls (Graph) aus Modulen  
‚ùå Schreiben in `entra`  
‚ùå Umgehen der zentralen DataSources-Re-Exports

### AI/RAG Integration Rules
**Bei `backend/src/modules/ai/**` √Ñnderungen:**
- ‚úÖ `docs/modules/ai/API.md` f√ºr Endpunkte `/api/ai/chat`, `/api/ai/rag/*` aktualisieren
- ‚úÖ Required ENV: `OPENAI_API_KEY`, `GEMINI_API_KEY`, `OLLAMA_URL`, `RAG_INDEX_PATH`

---

## üìö DOKUMENTATION & WARTUNG

### Dokumentations-Policy (KRITISCH)
- ‚úÖ Alle `.md`-Dateien M√úSSEN unter `docs/` liegen
- ‚úÖ Erlaubte Ausnahmen: `README.md` (root), `backend/README.md`, `frontend/README.md`
- ‚úÖ Pfadkonventionen:
  - Global: `docs/CHANGELOG.md`, `docs/INTERDEPENDENCY.md`
  - Module: `docs/modules/[module]/README.md`, `docs/modules/[module]/API.md`
  - Architektur: `docs/architecture/overview.md`

### Automatische Updates (PFLICHT)

#### Bei neuen Modulen:
1. ‚úÖ `docs/modules/[module]/README.md` erstellen  
2. ‚úÖ `docs/modules/[module]/API.md` erstellen  
3. ‚úÖ `docs/modules/[module]/CHANGELOG.md` erstellen  
4. ‚úÖ `docs/DOCUMENTATION_OVERVIEW.md` aktualisieren  
5. ‚úÖ `docs/INTERDEPENDENCY.md` um Dependencies erweitern  
6. ‚úÖ `docs/CHANGELOG.md` Version hinzuf√ºgen

#### Bei DataSources/Integrations (KRITISCH):
1. ‚úÖ `docs/INTERDEPENDENCY.md` - DataSources-Dependencies erweitern  
2. ‚úÖ `docs/INTERDEPENDENCY.md` - Environment-Variables dokumentieren  
3. ‚úÖ `docs/INTERDEPENDENCY.md` - External-API-Dependencies hinzuf√ºgen  
4. ‚úÖ `docs/DOCUMENTATION_OVERVIEW.md` - Integration-Architektur erweitern

#### Bei API-√Ñnderungen:
1. ‚úÖ `docs/modules/[module]/API.md` - Endpunkt-Dokumentation aktualisieren  
2. ‚úÖ `docs/modules/[module]/CHANGELOG.md` - API-Changes dokumentieren

#### Bei Frontend Theme-√Ñnderungen:
1. ‚úÖ `frontend/.env` - Neue `VITE_*` Variablen hinzuf√ºgen  
2. ‚úÖ `docs/INTERDEPENDENCY.md` - Frontend-Theme-Dependencies erweitern

### Documentation Gates (KRITISCH)
**Jede √Ñnderung in `backend/src/datasources/**` oder `backend/src/modules/**` (APIs/Routes) MUSS folgende Dokumente aktualisieren:**
- `docs/INTERDEPENDENCY.md`
- `docs/DOCUMENTATION_OVERVIEW.md`
- `docs/CHANGELOG.md`
- `docs/modules/[module]/API.md` (bei Endpoint-√Ñnderungen)
- `docs/modules/[module]/README.md` (bei Behavior-√Ñnderungen)

---
## üßπ MODUL LIFECYCLE

### Bei JEDEM neuen Modul (Checkliste):
1. ‚úÖ Backend-Ordnerstruktur nach Standard erstellen  
2. ‚úÖ Frontend-Ordnerstruktur nach Standard erstellen  
3. ‚úÖ Backend in `app.ts` registrieren  
4. ‚úÖ Frontend-Route in `App.tsx` registrieren  
5. ‚úÖ Sidebar-Navigation hinzuf√ºgen  
6. ‚úÖ Dashboard-Kachel erstellen  
7. ‚úÖ Permission-System integrieren  
8. ‚úÖ Vollst√§ndige Dokumentation erstellen  
9. ‚úÖ PowerShell-Tests erweitern

### Modul-Entfernung (KRITISCH):
**ALLE Abh√§ngigkeiten M√úSSEN systematisch entfernt werden:**

#### Backend-Entfernung:
1. ‚úÖ `backend/src/modules/[module]/` - Ordner l√∂schen  
2. ‚úÖ `backend/src/app.ts` - Import und Routes entfernen  
3. ‚úÖ `/api/hello` endpoint aktualisieren

#### Frontend-Entfernung:
1. ‚úÖ `frontend/src/modules/[module]/` - Ordner l√∂schen  
2. ‚úÖ `frontend/src/App.tsx` - Route entfernen  
3. ‚úÖ `frontend/src/layouts/components/Sidebar.tsx` - Navigation entfernen  
4. ‚úÖ `frontend/src/components/Dashboard.tsx` - Kachel entfernen

#### Dokumentations-Entfernung:
1. ‚úÖ `docs/modules/[module]/` - Ordner l√∂schen  
2. ‚úÖ `docs/DOCUMENTATION_OVERVIEW.md` - Referenzen entfernen  
3. ‚úÖ `docs/INTERDEPENDENCY.md` - Dependencies entfernen  
4. ‚úÖ `docs/CHANGELOG.md` - Entfernung dokumentieren

---
## ‚öôÔ∏è TECHNICAL STANDARDS

### Dependency Hygiene
- ‚úÖ Backend: `@types/*` packages in `devDependencies` only
- ‚úÖ Frontend: `react-router-dom` v6.x (nicht v7 ohne Migration)
- ‚úÖ Remove unused packages; add missing ones

### PowerShell Kompatibilit√§t  
- ‚úÖ Bevorzuge `;` statt `&&` in npm scripts
- ‚úÖ Erstelle `.ps1` Scripts f√ºr Module-spezifische Tasks
- ‚úÖ PowerShell-freundliche Pfade verwenden

### Testing Standards
- ‚úÖ Test-Funktionen in orchestrator f√ºr jedes Modul
- ‚úÖ PowerShell-Test-Scripts erstellen  
- ‚úÖ Mock-Daten f√ºr Entwicklung bereitstellen

---
**Wichtig**: Diese Regeln gew√§hrleisten Konsistenz, Wartbarkeit und Skalierbarkeit der CompanyAI-Architektur. Alle neuen Module M√úSSEN das hierarchische Permission-System ab v2.1.0 nutzen.






## Bei JEDEM neuen Modul:
1. ‚úÖ Ordnerstruktur nach Standard erstellen
2. ‚úÖ types.ts mit allen n√∂tigen Interfaces
3. ‚úÖ functions/ mit separaten Funktionsdateien  
4. ‚úÖ orchestrator.ts mit Route-Handlern
5. ‚úÖ Integration in index.ts
6. ‚úÖ Vollst√§ndige Dokumentation erstellen:
   - docs/modules/[module]/README.md
   - docs/modules/[module]/API.md
   - docs/modules/[module]/CHANGELOG.md
7. ‚úÖ **KRITISCH: Dokumentations-Wartung**
   - docs/DOCUMENTATION_OVERVIEW.md erweitern
   - docs/INTERDEPENDENCY.md um Dependencies erweitern
   - docs/README.md Module-Liste aktualisieren
   - docs/CHANGELOG.md Version hinzuf√ºgen
8. ‚úÖ Test-Script erweitern
9. ‚úÖ Haupt-Dokumentation aktualisieren

## Bei JEDER neuen DataSource/Integration:
1. ‚úÖ Ordnerstruktur in `backend/src/datasources/[source]/` erstellen
2. ‚úÖ Types, Store, Client/Sync-Logik implementieren
3. ‚úÖ API-Routes in `backend/src/app.ts` registrieren
4. ‚úÖ .env Variablen hinzuf√ºgen und dokumentieren
5. ‚úÖ **KRITISCH: INTERDEPENDENCY.md aktualisieren**
   - DataSources-Dependencies-Sektion erweitern
   - Environment-Variables (.env) dokumentieren
   - External-API-Dependencies hinzuf√ºgen
   - Frontend-API-Bindings dokumentieren
   - Cross-DataSource Dependencies dokumentieren
6. ‚úÖ `docs/DOCUMENTATION_OVERVIEW.md` erweitern
7. ‚úÖ `docs/CHANGELOG.md` aktualisieren
8. ‚úÖ Frontend-Integration planen und dokumentieren

## Neue Module ‚Äì Verbindliche Backend-/Frontend-Integration (KRITISCH)

### Backend (Pflicht)
- Ordner: `backend/src/modules/[module]/` mit Struktur gem√§√ü Modulstandards (siehe oben)
- Routen-Registrierung: `register[Module]Routes(apiRouter)` in `backend/src/app.ts` hinzuf√ºgen
- Auth: `requireAuth`/`requirePermission` konsequent verwenden
- Health/Hello: Endpunkt-Liste in `/api/hello` um Modul erg√§nzen (Beschreibung + Endpunkte)
- Tests: Mindestens Health-/Routing-Test f√ºr neues Modul

### Frontend (Pflicht)
- Ordner: `frontend/src/modules/[module]/` mit:
  - `[Module]Module.tsx` (interner Router gem√§√ü Standard)
  - `pages/` (mind. eine Page-Komponente)
  - `styles/[Module]Pages.css`
- Router: In `frontend/src/App.tsx` Route f√ºr das Modul registrieren:
  - `<Route path="/[module]/*" element={<MainLayout><[Module]Module /></MainLayout>} />` (mit `RequireAuth` Wrapper)
- Navigation (Pflicht): In `frontend/src/layouts/components/Sidebar.tsx` Navigations-Eintrag hinzuf√ºgen (inkl. Submenu, falls zutreffend)
- UI-Standards: Vorhandene CSS-Klassen verwenden (page-header, content-section, etc.)

### Page-Struktur je Modul (Pflicht)
- F√ºr JEDES fachliche Feature im Modul MUSS eine eigene Page-Komponente angelegt werden:
  - `frontend/src/modules/[module]/pages/[Feature]Page.tsx`
  - Beispiele: `EmployeesPage.tsx`, `OnboardingPage.tsx`, `ReportsPage.tsx`, `StatsPage.tsx`
- Der Modul-Router MUSS alle Feature-Pages per Route erreichbar machen:
  - `/[module]/[feature]` ‚Üí rendert die korrekte `[Feature]Page`
- Die Sidebar MUSS ein Submenu mit Eintr√§gen f√ºr alle Feature-Pages enthalten
- Jede neue Page MUSS Loading-, Error- und Empty-States gem√§√ü Standard implementieren und die Auth-Header bei API-Calls verwenden

### Dashboard-Integration (Pflicht)
- `frontend/src/components/Dashboard.tsx` um eine Modul-Kachel/-Sektion erweitern:
  - Titel: Modulname (Icon optional)
  - Kurzbeschreibung (1‚Äì2 S√§tze)
  - Link/Action: Button zur Modul-Startseite (`/[module]`)
  - Optional: einfache Kennzahlen (falls verf√ºgbar)
- Kachel-Layout, Klassen und Stil gem√§√ü bestehenden Dashboard-Karten verwenden.

### Dokumentation & Scripte (Pflicht)
- `docs/modules/[module]/` erstellen (README.md, API.md, CHANGELOG.md)
- `docs/DOCUMENTATION_OVERVIEW.md` und `docs/INTERDEPENDENCY.md` um neues Modul und Abh√§ngigkeiten erg√§nzen
- PowerShell-Skripte anpassen (Tests/Checks), falls relevant

Hinweis: Module ohne vollst√§ndige Backend-Registrierung, Frontend-Router-Integration und Sidebar-Navigation werden nicht angenommen. F√ºr jedes neue Modul m√ºssen die Routen in `App.tsx` registriert und passende Navigationseintr√§ge in `Sidebar.tsx` erg√§nzt werden.

Zus√§tzlich ist die Dashboard-Integration Pflicht: F√ºr jedes neue Modul muss eine Kachel im Dashboard vorhanden sein, die zur Route `/[module]` f√ºhrt und das Modul kurz beschreibt.

## Frontend-Standards (React + TypeScript)

### Frontend-Modulstruktur - Befolge IMMER:
```
frontend/src/
‚îú‚îÄ‚îÄ layouts/                    # Layout-Komponenten (wiederverwendbar)
‚îÇ   ‚îú‚îÄ‚îÄ MainLayout.tsx         # Haupt-Layout mit Header + Sidebar
‚îÇ   ‚îú‚îÄ‚îÄ AuthLayout.tsx         # Login/Auth-Layout
‚îÇ   ‚îî‚îÄ‚îÄ components/
‚îÇ       ‚îú‚îÄ‚îÄ Header.tsx         # Globaler Header
‚îÇ       ‚îî‚îÄ‚îÄ Sidebar.tsx        # Navigation-Sidebar
‚îú‚îÄ‚îÄ modules/                   # Modulbasierte Komponenten
‚îÇ   ‚îú‚îÄ‚îÄ [module]/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [Module]Module.tsx # Haupt-Modul mit Router
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pages/            # Seiten-Komponenten
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [Page]Page.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [Page]Page.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ styles/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ [Module]Pages.css
‚îÇ   ‚îî‚îÄ‚îÄ auth/
‚îÇ       ‚îî‚îÄ‚îÄ LoginPage.tsx
‚îú‚îÄ‚îÄ components/                # Globale UI-Komponenten
‚îÇ   ‚îú‚îÄ‚îÄ Dashboard.tsx
‚îÇ   ‚îî‚îÄ‚îÄ [Component].tsx
‚îî‚îÄ‚îÄ App.tsx                   # Router-Konfiguration
```

### Frontend-Datei-Standards:

#### 1. Modul-Router-Pattern:
```typescript
// [Module]Module.tsx - IMMER diese Struktur
import React from 'react';
import { Routes, Route, Navigate } from 'react-router-dom';
import [Page]Page from './pages/[Page]Page';

const [Module]Module: React.FC = () => {
  return (
    <div className="[module]-module">
      <Routes>
        <Route path="/" element={<Navigate to="/[module]/[default]" replace />} />
        <Route path="/[page]" element={<[Page]Page />} />
        <Route path="*" element={<Navigate to="/[module]/[default]" replace />} />
      </Routes>
    </div>
  );
};

export default [Module]Module;
```

#### 2. Page-Komponenten-Pattern:
```typescript
// pages/[Page]Page.tsx - IMMER diese Struktur
import React, { useState, useEffect } from 'react';
import '../styles/[Module]Pages.css';

interface [Entity] {
  id: string;
  // weitere Properties
}

const [Page]Page: React.FC = () => {
  const [data, setData] = useState<[Entity][]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    loadData();
  }, []);

  const loadData = async () => {
    try {
      setLoading(true);
      setError(null);

      const token = localStorage.getItem('authToken');
      const response = await fetch('http://localhost:5000/api/[module]/[endpoint]', {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });

      const result = await response.json();
      if (result.success && result.data) {
        setData(result.data.data || result.data);
      } else {
        setError(result.message || 'Fehler beim Laden');
      }
    } catch (err) {
      setError('Verbindungsfehler zum Backend');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="[module]-page">
      <div className="page-header">
        <div className="page-title">
          <h1>[Icon] [Title]</h1>
          <p>[Description]</p>
        </div>
        <div className="page-actions">
          <button className="btn btn-primary">
            [Action]
          </button>
        </div>
      </div>

      <div className="content-section">
        {/* Content hier */}
      </div>
    </div>
  );
};

export default [Page]Page;
```

#### 3. CSS-Standards - Folge IMMER diesen Klassen:
```css
/* Basis-Layout-Klassen */
.[module]-page          # Haupt-Container
.page-header           # Header mit Titel und Actions
.page-title            # Titel-Bereich
.page-actions          # Button-Bereich
.content-section       # Haupt-Inhalt
.filters-section       # Filter-Bereich
.page-summary          # Zusammenfassung unten

/* Button-Klassen */
.btn                   # Basis-Button
.btn-primary           # Haupt-Action (blau)
.btn-secondary         # Sekund√§r-Action (grau)
.btn-success           # Erfolg-Action (gr√ºn)
.btn-small             # Kleine Buttons
.btn-outline           # Umrandete Buttons

/* Status-Klassen */
.loading-state         # Loading-Zustand
.error-state           # Fehler-Zustand
.empty-state           # Leerer Zustand

/* Layout-Modi */
.main-layout.fullwidth # Vollbild-Layout
.main-layout.compact   # Kompaktes Layout
```

### API-Integration-Standards:

#### 1. Authentifizierung - IMMER verwenden:
```typescript
const token = localStorage.getItem('authToken');
const headers = {
  'Authorization': `Bearer ${token}`,
  'Content-Type': 'application/json'
};
```

#### 2. Error-Handling - IMMER implementieren:
```typescript
try {
  // API-Call
} catch (err) {
  setError('Verbindungsfehler zum Backend');
  console.error('Fehler beim [Action]:', err);
}
```

#### 3. Loading-States - IMMER verwenden:
```typescript
const [loading, setLoading] = useState(true);

// In JSX:
{loading && (
  <div className="loading-state">
    <div className="loading-spinner"></div>
    <p>Lade [Data]...</p>
  </div>
)}
```

### Router-Integration-Standards:

#### 1. App.tsx - Router-Struktur:
```typescript
// IMMER diese Router-Struktur befolgen
<Router>
  <Routes>
    <Route path="/login" element={
      <AuthLayout><LoginPage /></AuthLayout>
    } />
    <Route path="/[module]/*" element={
      <MainLayout><[Module]Module /></MainLayout>
    } />
    <Route path="*" element={<Navigate to="/" replace />} />
  </Routes>
</Router>
```

#### 2. Layout-Integration - Module nutzen Layouts automatisch:
```typescript
// Layout wird durch Router bereitgestellt, nicht direkt importiert
// Module erhalten Layout-Context automatisch
```

### State-Management-Standards:

#### 1. Lokaler State f√ºr Seiten-Daten:
```typescript
const [data, setData] = useState<Type[]>([]);
const [loading, setLoading] = useState(true);
const [error, setError] = useState<string | null>(null);
const [filters, setFilters] = useState({ /* filter object */ });
```

#### 2. localStorage f√ºr User-Daten:
```typescript
// Authentifizierung
localStorage.getItem('authToken')
localStorage.getItem('userRole')
localStorage.getItem('userName')
```

### Naming-Conventions Frontend:

#### Komponenten:
- PascalCase: `EmployeesPage.tsx`, `HeaderComponent.tsx`
- Seiten enden mit `Page`: `EmployeesPage`, `DashboardPage`
- Module enden mit `Module`: `HRModule`, `SupportModule`

#### CSS-Klassen:
- kebab-case: `.employee-card`, `.ticket-list`
- Modul-Pr√§fix: `.hr-page`, `.support-module`
- Status-Pr√§fix: `.status-active`, `.priority-high`

#### Dateien:
- Komponenten: PascalCase.tsx
- Styles: PascalCase.css oder kebab-case.css
- Module-Ordner: lowercase mit Bindestrich

## Frontend-Integration-Checkliste:

### Bei JEDEM neuen Frontend-Modul:
1. ‚úÖ Modul-Ordner in `src/modules/[module]/` erstellen
2. ‚úÖ `[Module]Module.tsx` mit Router-Setup
3. ‚úÖ `pages/` Ordner mit mindestens einer Seite
4. ‚úÖ `styles/[Module]Pages.css` f√ºr Modul-Styles
5. ‚úÖ Integration in `App.tsx` Router
6. ‚úÖ Navigation in `Sidebar.tsx` hinzuf√ºgen
7. ‚úÖ API-Integration mit Backend-Endpunkten
8. ‚úÖ Error-Handling und Loading-States
9. ‚úÖ Responsive Design testen
10. ‚úÖ **KRITISCH: Dokumentations-Wartung**
    - docs/DOCUMENTATION_OVERVIEW.md um Frontend-Inhalte erweitern
    - docs/INTERDEPENDENCY.md um Frontend-Dependencies erweitern
    - docs/modules/[module]/README.md um Frontend-Sektion erweitern
    - docs/README.md Frontend-Features aktualisieren

## Frontend NICHT ERLAUBT:
‚ùå Direkte Layout-Imports in Modulen
‚ùå Inline-Styles statt CSS-Klassen
‚ùå API-Calls ohne Error-Handling
‚ùå Fehlende Loading-States
‚ùå Untypisierte Komponenten-Props
‚ùå Fehlende Responsive-Design
‚ùå Module ohne Router-Integration
‚ùå Authentifizierung umgehen
‚ùå Frontend-Module ohne Dokumentations-Updates
‚ùå Neue Pages ohne INTERDEPENDENCY.md Dependencies-Update
‚ùå CSS-√Ñnderungen ohne Shared-Component-Dokumentation

## Modul-Entfernung und L√∂schung (KRITISCH)

Wenn ein Modul entfernt oder gel√∂scht werden soll, M√úSSEN ALLE Abh√§ngigkeiten systematisch entfernt werden:

### Backend-Entfernung (Pflicht):
```bash
1. ‚úÖ backend/src/modules/[module]/ - Kompletten Ordner l√∂schen
2. ‚úÖ backend/src/app.ts - Import und register[Module]Routes() entfernen
3. ‚úÖ backend/src/app.ts - Modul aus /api/health und /api/hello Endpunkten entfernen
4. ‚úÖ Alle Tests die das Modul referenzieren l√∂schen/anpassen
5. ‚úÖ Package.json Dependencies pr√ºfen (falls modul-spezifische Packages)
```

### Frontend-Entfernung (Pflicht):
```bash
1. ‚úÖ frontend/src/modules/[module]/ - Kompletten Ordner l√∂schen
2. ‚úÖ frontend/src/App.tsx - Route "/[module]/*" komplett entfernen
3. ‚úÖ frontend/src/layouts/components/Sidebar.tsx - Navigation-Eintrag entfernen
4. ‚úÖ frontend/src/components/Dashboard.tsx - Modul-Kachel entfernen
5. ‚úÖ Alle Imports/Referenzen auf das Modul in anderen Komponenten entfernen
6. ‚úÖ CSS-Klassen pr√ºfen die modul-spezifisch waren (falls global verwendet)
```

### Dokumentations-Entfernung (KRITISCH):
```bash
1. ‚úÖ docs/modules/[module]/ - Kompletten Ordner l√∂schen
2. ‚úÖ docs/DOCUMENTATION_OVERVIEW.md - Modul-Referenzen entfernen
3. ‚úÖ docs/INTERDEPENDENCY.md - Alle Dependencies zum Modul entfernen
4. ‚úÖ docs/README.md - Modul aus Listen und Metriken entfernen
5. ‚úÖ docs/CHANGELOG.md - Eintrag √ºber Modul-Entfernung hinzuf√ºgen:
   ```markdown
   ## [Version] - [Datum]
   ### Entfernt
   - **[Module] Modul komplett entfernt**
     - Backend: Ordner, Routen, Tests
     - Frontend: Komponenten, Router, Navigation, Dashboard-Kachel
     - Dokumentation: Modul-Docs, Dependencies, Referenzen
     - Grund: [Begr√ºndung f√ºr Entfernung]
   ```
```

### Vollst√§ndigkeits-Check nach Modul-Entfernung:
```bash
‚úÖ Keine Backend-Imports/Routes mehr vorhanden?
‚úÖ Keine Frontend-Components/Routes mehr vorhanden?
‚úÖ Alle Navigation-Links entfernt?
‚úÖ Dashboard ohne Modul-Kachel?
‚úÖ Dokumentation komplett bereinigt?
‚úÖ CHANGELOG.md dokumentiert Entfernung?
‚úÖ Keine broken Links in verbleibender Dokumentation?
‚úÖ Tests laufen noch durch?
‚úÖ Frontend startet ohne Fehler?
‚úÖ Backend startet ohne Fehler?
```

### Entfernungs-Reihenfolge (Empfohlen):
```bash
1. üî¥ CHANGELOG.md - Entfernung dokumentieren (mit Begr√ºndung)
2. üîÑ Frontend - Routen, Navigation, Dashboard bereinigen
3. üîÑ Backend - Ordner, Imports, Routen entfernen
4. üìö Dokumentation - Referenzen und Dependencies bereinigen
5. ‚úÖ Tests - Vollst√§ndigkeits-Check durchf√ºhren
```

### NICHT ERLAUBT bei Modul-Entfernung:
‚ùå Modul-Ordner l√∂schen ohne Route-Bereinigung
‚ùå Backend/Frontend teilweise entfernt lassen
‚ùå Navigation-Links zu gel√∂schtem Modul
‚ùå Broken Dashboard-Kacheln
‚ùå Verwaiste Dokumentations-Referenzen
‚ùå Fehlende CHANGELOG.md Dokumentation der Entfernung
‚ùå Dependencies in INTERDEPENDENCY.md nicht bereinigt
‚ùå Tests die auf gel√∂schte Module verweisen

**Wichtig**: Eine Modul-Entfernung ist ein Breaking Change und MUSS ausf√ºhrlich in docs/CHANGELOG.md dokumentiert werden, inklusive Begr√ºndung und Auswirkungen auf andere Module.

## Hierarchical Permissions Integration (KRITISCH - NEU v2.1.0)

Bei JEDEM neuen Modul MUSS die Integration in das hierarchische Permission-System ber√ºcksichtigt werden:

### Modul-Permission-Definition (PFLICHT):
```bash
1. ‚úÖ Modul-Schl√ºssel definieren (z.B. "analytics", "reporting", "inventory")
2. ‚úÖ Page-Definitionen mit Actions erstellen:
   - Page-Keys: beschreibende Namen (z.B. "reports", "dashboards", "export")
   - Actions: view, create, edit, delete, export, import, etc.
   - Limits (optional): dailyQuota, maxRecords, etc.
3. ‚úÖ Modul-spezifische Permission-Logik implementieren
4. ‚úÖ Backend-Permission-Checks in orchestrator.ts-Handlern
5. ‚úÖ Frontend-Permission-Guards f√ºr Pages und Features
```

### Backend-Integration mit Permission-System:
```typescript
// orchestrator.ts - IMMER Permission-Checks einbauen
import { AuthenticatedRequest, requirePermission } from '../hr/core/auth';

export class [Module]Orchestrator {
  static async handle[Action](req: AuthenticatedRequest, res: Response) {
    // Permission-Check f√ºr hierarchisches System
    const hasPermission = await checkHierarchicalPermission(
      req.user.id, 
      '[module]', 
      '[page]', 
      '[action]'
    );
    
    if (!hasPermission) {
      return res.status(403).json({
        success: false,
        error: 'PermissionDenied',
        message: 'Keine Berechtigung f√ºr diese Aktion'
      });
    }
    
    // Rest der Handler-Logik...
  }
}
```

### Frontend-Permission-Guards:
```typescript
// pages/[Page]Page.tsx - Permission-Guards implementieren
import { useUserPermissions } from '../../../hooks/useUserPermissions';

const [Page]Page: React.FC = () => {
  const { hasPageAccess, hasPageAction } = useUserPermissions();
  
  // Page-Level Guard
  if (!hasPageAccess('[module]', '[page]')) {
    return (
      <div className="error-state">
        <h2>üö´ Zugriff verweigert</h2>
        <p>Sie haben keine Berechtigung f√ºr diese Seite.</p>
      </div>
    );
  }
  
  // Feature-Level Guards im JSX
  return (
    <div className="[module]-page">
      {/* Conditional Features basierend auf Permissions */}
      {hasPageAction('[module]', '[page]', 'create') && (
        <button className="btn btn-primary">Neu erstellen</button>
      )}
      {hasPageAction('[module]', '[page]', 'export') && (
        <button className="btn btn-secondary">Exportieren</button>
      )}
    </div>
  );
};
```

### hierarchyAnalyzer.ts erweitern (Backend):
```typescript
// Neue Module m√ºssen in die Modul-Definitionen eingepflegt werden
export const MODULE_DEFINITIONS = [
  {
    key: "hr",
    name: "HR", 
    icon: "üë•",
    pages: [...]
  },
  {
    key: "[new-module]",
    name: "[Module Display Name]",
    icon: "[Icon]",
    pages: [
      {
        key: "[page1]",
        name: "[Page Display Name]",
        icon: "[Page Icon]",
        actions: [
          { key: "view", name: "Anzeigen", description: "..." },
          { key: "create", name: "Erstellen", description: "..." },
          { key: "edit", name: "Bearbeiten", description: "..." },
          { key: "delete", name: "L√∂schen", description: "..." }
        ],
        limits: [ // Optional
          { key: "dailyQuota", name: "T√§gliche Anfragen", type: "number", defaultValue: 100 }
        ]
      }
    ]
  }
];
```

### Permission-System-Integration-Checkliste (PFLICHT):

#### Bei JEDEM neuen Backend-Modul:
```bash
1. ‚úÖ Module-Definition in hierarchyAnalyzer.ts hinzuf√ºgen (Modul + Pages + Actions)
2. ‚úÖ Permission-Checks in alle orchestrator.ts Handler einbauen
3. ‚úÖ Modul-spezifische Permission-Logic implementieren (falls n√∂tig)
4. ‚úÖ API-Endpunkte f√ºr Permission-Management erweitern (falls n√∂tig)
5. ‚úÖ Tests f√ºr Permission-Scenarios schreiben
```

#### Bei JEDEM neuen Frontend-Modul:
```bash
1. ‚úÖ useUserPermissions Hook in alle Pages integrieren
2. ‚úÖ Permission-Guards f√ºr Page-Access implementieren
3. ‚úÖ Feature-Guards f√ºr Actions implementieren (Create/Edit/Delete buttons)
4. ‚úÖ Conditional UI basierend auf User-Permissions
5. ‚úÖ Error-States f√ºr Permission-Denied-Scenarios
6. ‚úÖ Loading-States w√§hrend Permission-Checks
```

#### Dokumentations-Updates (KRITISCH):
```bash
1. ‚úÖ docs/modules/[module]/README.md - Permission-Sektion hinzuf√ºgen:
   - Welche Permissions das Modul nutzt
   - Hierarchische Integration (Department/SubGroup/Individual)
   - Permission-Dependencies zu anderen Modulen
2. ‚úÖ docs/modules/[module]/API.md - Permission-Requirements dokumentieren:
   - Welche Permission f√ºr welchen Endpoint erforderlich
   - Hierarchische Permission-Checks beschreiben
   - Error-Responses bei Permission-Denied
3. ‚úÖ docs/INTERDEPENDENCY.md - Permission-Dependencies erg√§nzen:
   - Modul-spezifische Permission-Integration
   - Cross-Module-Permission-Dependencies
   - Hierarchical Permission System Integration
4. ‚úÖ docs/DOCUMENTATION_OVERVIEW.md - Permission-Dokumentation erweitern
5. ‚úÖ docs/CHANGELOG.md - Neue Permission-Integration dokumentieren
```

### NICHT ERLAUBT (Hard-Fails):
‚ùå Neue Module ohne Permission-System-Integration
‚ùå Frontend-Pages ohne Permission-Guards  
‚ùå Backend-APIs ohne hierarchische Permission-Checks
‚ùå Module-Definitionen nicht in hierarchyAnalyzer.ts hinzugef√ºgt
‚ùå Permission-Integration ohne Dokumentations-Update
‚ùå Features ohne Action-Level-Permission-Checks
‚ùå Permission-System umgehen oder direkt auf alte Auth zur√ºckgreifen
‚ùå Neue Module ohne Permission-Test-Scenarios

### Beispiel-Integration neues "Analytics"-Modul:

#### 1. Backend hierarchyAnalyzer.ts erweitern:
```typescript
{
  key: "analytics",
  name: "Analytics", 
  icon: "üìä",
  pages: [
    {
      key: "reports",
      name: "Berichte",
      icon: "üìà",
      actions: [
        { key: "view", name: "Anzeigen", description: "Berichte anzeigen" },
        { key: "create", name: "Erstellen", description: "Neue Berichte erstellen" },
        { key: "export", name: "Exportieren", description: "Berichte exportieren" },
        { key: "delete", name: "L√∂schen", description: "Berichte l√∂schen" }
      ],
      limits: [
        { key: "monthlyReports", name: "Berichte pro Monat", type: "number", defaultValue: 10 }
      ]
    }
  ]
}
```

#### 2. Backend orchestrator.ts mit Permission-Checks:
```typescript
static async handleGetReports(req: AuthenticatedRequest, res: Response) {
  const hasPermission = await checkHierarchicalPermission(
    req.user.id, 'analytics', 'reports', 'view'
  );
  
  if (!hasPermission) {
    return res.status(403).json({
      success: false,
      error: 'PermissionDenied',
      message: 'Keine Berechtigung um Analytics-Berichte zu sehen'
    });
  }
  
  // Rest der Logic...
}
```

#### 3. Frontend Permission-Guards:
```typescript
const ReportsPage: React.FC = () => {
  const { hasPageAccess, hasPageAction } = useUserPermissions();
  
  if (!hasPageAccess('analytics', 'reports')) {
    return <PermissionDenied />;
  }
  
  return (
    <div className="analytics-page">
      <div className="page-actions">
        {hasPageAction('analytics', 'reports', 'create') && (
          <button>Neuen Bericht erstellen</button>
        )}
        {hasPageAction('analytics', 'reports', 'export') && (
          <button>Exportieren</button>
        )}
      </div>
    </div>
  );
};
```

### Migration bestehender Module:

Bestehende Module M√úSSEN schrittweise in das hierarchische Permission-System integriert werden:

```bash
1. ‚úÖ Modul-Definition hinzuf√ºgen (hierarchyAnalyzer.ts)
2. ‚úÖ Permission-Checks schrittweise in Backend einbauen
3. ‚úÖ Frontend-Guards schrittweise hinzuf√ºgen  
4. ‚úÖ Dokumentation aktualisieren
5. ‚úÖ Tests erweitern
6. ‚úÖ Migration in CHANGELOG.md dokumentieren
```

**Wichtig**: Das hierarchische Permission-System ist ab v2.1.0 der neue Standard. Alle neuen Module M√úSSEN dieses System von Anfang an nutzen. Bestehende Module m√ºssen sukzessive migriert werden.

Diese Regeln gew√§hrleisten Konsistenz, Wartbarkeit und Skalierbarkeit der CompanyAI-Architektur.
