# CompanyAI - Entwicklungsregeln & Standards

## ğŸš€ Must-Pass Checks (CI/Local)
- Run `npm run check:rules` before build/merge
- Build must pass: `npm run build` runs rule checks via prebuild
- Script `tools/verify-rules.ps1` performs automated checks and must pass

---

## ğŸ—ï¸ BACKEND-ARCHITEKTUR

### Module-Standards (PFLICHT)
Befolge IMMER diese modulbasierte Struktur fÃ¼r `backend/src/modules/`:

```
backend/src/modules/[module-name]/
â”œâ”€â”€ orchestrator.ts        # PFLICHT: API-Route-Handler
â”œâ”€â”€ types.ts              # PFLICHT: TypeScript-Interfaces  
â”œâ”€â”€ core/                 # OPTIONAL: Wiederverwendbare Hilfslogik
â”‚   â””â”€â”€ [helper-files].ts # z.B. auth.ts, utils.ts, validators.ts
â””â”€â”€ functions/            # PFLICHT: GeschÃ¤ftslogik-Funktionen
    â”œâ”€â”€ [function1].ts    # Eine Funktion pro Datei
    â”œâ”€â”€ [function2].ts    # Klare, beschreibende Namen
    â””â”€â”€ [function3].ts    # Export von async functions
```

### Code-Templates (PFLICHT)

#### 1. types.ts - IMMER enthalten:
```typescript
// Request-Typen
export interface Create[Entity]Request { ... }
export interface Update[Entity]Request { ... }

// Entity-Typen
export interface [Entity] { 
  id: string;
  // weitere Properties
}

// Response-Typen
export interface APIResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
}
```

#### 2. orchestrator.ts - IMMER enthalten:
```typescript
import { Request, Response } from 'express';
import { AuthenticatedRequest } from '../hr/core/auth';

export class [Module]Orchestrator {
  static async handle[Action](req: AuthenticatedRequest, res: Response) {
    // Handler-Implementation
  }
}

export function register[Module]Routes(router: any) {
  // Route-Registrierung
}
```

#### 3. functions/[function].ts - Eine Funktion pro Datei:
```typescript
export async function [functionName](
  request: [Request]Type
): Promise<APIResponse<[Entity]>> {
  try {
    return { success: true, data: result, message: 'Success' };
  } catch (error) {
    return { success: false, error: 'Error', message: 'Failed' };
  }
}
```

### Integration-Requirements (PFLICHT)
1. âœ… Module MÃœSSEN in `backend/src/app.ts` registriert werden
2. âœ… Import: `import { register[Module]Routes } from './modules/[module]/orchestrator';`
3. âœ… Route registrieren: `register[Module]Routes(apiRouter);`
4. âœ… Module-Liste in `/api/hello` endpoint aktualisieren
5. âœ… Alle Responses nutzen `APIResponse<T>` Format
6. âœ… Deutsche Fehlermeldungen fÃ¼r User, englische Error-Types fÃ¼r Logging
7. âœ… PowerShell-Test-Scripts erstellen

### Naming Conventions
- **Module-Namen**: `hr`, `support`, `user-management` (lowercase mit Bindestrichen)
- **API-Routen**: RESTful `/api/[module]/[entities]`
- **Funktions-Namen**: Verben verwenden (`createEmployee`, `fetchTickets`)
- **Datei-Namen**: camelCase (`createHRReport.ts`, `manageTickets.ts`)

### NICHT ERLAUBT (Backend):
âŒ Module ohne `orchestrator.ts` oder `types.ts`  
âŒ GeschÃ¤ftslogik direkt in `orchestrator.ts`  
âŒ Fehlende Error-Handling  
âŒ Untypisierte API-Responses  
âŒ Module, die nicht in `app.ts` registriert sind  
âŒ Direkte Datenbankzugriffe ohne Abstraktionsschicht

---
## ğŸ’» FRONTEND-ARCHITEKTUR

### Module-Standards (PFLICHT)
```
frontend/src/modules/[module]/
â”œâ”€â”€ [Module]Module.tsx     # Haupt-Modul mit Router
â”œâ”€â”€ pages/                # Seiten-Komponenten
â”‚   â”œâ”€â”€ [Feature]Page.tsx
â”‚   â””â”€â”€ [Feature]Page.tsx
â””â”€â”€ styles/
    â””â”€â”€ [Module]Pages.css
```

### Code-Templates (PFLICHT)

#### 1. Modul-Router-Pattern:
```typescript
const [Module]Module: React.FC = () => {
  return (
    <div className="[module]-module">
      <Routes>
        <Route path="/" element={<Navigate to="/[module]/[default]" replace />} />
        <Route path="/[page]" element={<[Page]Page />} />
        <Route path="*" element={<Navigate to="/[module]/[default]" replace />} />
      </Routes>
    </div>
  );
};
```

#### 2. Page-Komponenten-Pattern:
```typescript
const [Page]Page: React.FC = () => {
  const [data, setData] = useState<[Entity][]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const loadData = async () => {
    try {
      const token = localStorage.getItem('authToken');
      const response = await fetch('http://localhost:5000/api/[module]/[endpoint]', {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });
      // Error-Handling...
    } catch (err) {
      setError('Verbindungsfehler zum Backend');
    }
  };

  return (
    <div className="[module]-page">
      <div className="page-header">
        <div className="page-title">
          <h1>[Title]</h1>
        </div>
      </div>
      <div className="content-section">
        {/* Content */}
      </div>
    </div>
  );
};
```

### CSS-Standards (PFLICHT)
```css
/* Basis-Layout-Klassen */
.[module]-page          # Haupt-Container
.page-header           # Header mit Titel und Actions
.page-title            # Titel-Bereich
.content-section       # Haupt-Inhalt

/* Button-Klassen */
.btn                   # Basis-Button
.btn-primary           # Haupt-Action (blau)
.btn-secondary         # SekundÃ¤r-Action (grau)

/* Status-Klassen */
.loading-state         # Loading-Zustand
.error-state           # Fehler-Zustand
.empty-state           # Leerer Zustand
```

### Integration-Requirements (PFLICHT)
1. âœ… Route in `frontend/src/App.tsx` registrieren
2. âœ… Navigation in `frontend/src/layouts/components/Sidebar.tsx` hinzufÃ¼gen
3. âœ… Dashboard-Kachel in `frontend/src/components/Dashboard.tsx` erstellen
4. âœ… Loading-, Error- und Empty-States implementieren
5. âœ… Auth-Token bei allen API-Calls verwenden
6. âœ… Responsive Design testen

### Icon-Standards (PFLICHT)
**Verwende IMMER Heroicons statt Emojis im Frontend:**
```typescript
// âœ… RICHTIG - Heroicons verwenden
import { UserIcon, HomeIcon, ChartBarIcon, XMarkIcon } from '@heroicons/react/24/outline';

const ExampleComponent = () => (
  <button className="btn">
    <UserIcon className="h-5 w-5" />
    Benutzer verwalten
  </button>
);

// âŒ FALSCH - Emojis verwenden  
const BadExample = () => (
  <button className="btn">
    ğŸ‘¥ Benutzer verwalten  // âŒ Keine Emojis!
  </button>
);
```

**Heroicons-Setup:**
1. âœ… Package installieren: `npm install @heroicons/react`
2. âœ… Import: `import { IconName } from '@heroicons/react/24/outline'` (fÃ¼r Outline-Style)
3. âœ… Import: `import { IconName } from '@heroicons/react/24/solid'` (fÃ¼r Solid-Style)
4. âœ… CSS-Klassen verwenden: `className="h-5 w-5"` fÃ¼r GrÃ¶ÃŸen
5. âœ… Konsistente Icon-GrÃ¶ÃŸen: `h-4 w-4` (klein), `h-5 w-5` (normal), `h-6 w-6` (groÃŸ)

**Standard-Icons fÃ¼r hÃ¤ufige Aktionen:**
- Benutzer: `UserIcon`, `UsersIcon`
- Navigation: `HomeIcon`, `ChevronRightIcon`, `Bars3Icon`
- Aktionen: `PlusIcon`, `PencilIcon`, `TrashIcon`, `XMarkIcon`
- Status: `CheckIcon`, `XMarkIcon`, `ExclamationTriangleIcon`
- Dokumente: `DocumentIcon`, `FolderIcon`, `ArchiveBoxIcon`

### NICHT ERLAUBT (Frontend):
âŒ Direkte Layout-Imports in Modulen  
âŒ Inline-Styles statt CSS-Klassen  
âŒ API-Calls ohne Error-Handling  
âŒ Fehlende Loading-States  
âŒ Module ohne Router-Integration  
âŒ Authentifizierung umgehen
âŒ **Emojis statt Heroicons verwenden** ğŸš«
âŒ **Inkonsistente Icon-GrÃ¶ÃŸen** 
âŒ **Icons ohne CSS-Klassen fÃ¼r Sizing**

---
## ğŸ” USER & PERMISSIONS SYSTEM

### Authentifizierung (PFLICHT fÃ¼r alle Module)
```typescript
// Backend - IMMER nutzen:
import { AuthenticatedRequest, requireAuth, requirePermission } from '../hr/core/auth';
// FÃ¼r geschÃ¼tzte Routes: requireAuth oder requirePermission(action, resource)
// Logging: logAuthEvent(userId, action, resource)

// Frontend - IMMER nutzen:
const token = localStorage.getItem('authToken');
const headers = {
  'Authorization': `Bearer ${token}`,
  'Content-Type': 'application/json'
};
```

### Hierarchical Permissions Integration (KRITISCH - v2.1.0+)

**Bei JEDEM neuen Modul PFLICHT:**

#### 1. Backend hierarchyAnalyzer.ts erweitern:
```typescript
export const MODULE_DEFINITIONS = [
  {
    key: "[new-module]",
    name: "[Module Display Name]",
    icon: "[Icon]",
    pages: [
      {
        key: "[page1]",
        name: "[Page Display Name]",
        icon: "[Page Icon]",
        actions: [
          { key: "view", name: "Anzeigen", description: "..." },
          { key: "create", name: "Erstellen", description: "..." },
          { key: "edit", name: "Bearbeiten", description: "..." },
          { key: "delete", name: "LÃ¶schen", description: "..." }
        ],
        limits: [ // Optional
          { key: "dailyQuota", name: "TÃ¤gliche Anfragen", type: "number", defaultValue: 100 }
        ]
      }
    ]
  }
];
```

#### 2. Backend Permission-Checks (PFLICHT):
```typescript
export class [Module]Orchestrator {
  static async handle[Action](req: AuthenticatedRequest, res: Response) {
    const hasPermission = await checkHierarchicalPermission(
      req.user.id, '[module]', '[page]', '[action]'
    );
    
    if (!hasPermission) {
      return res.status(403).json({
        success: false,
        error: 'PermissionDenied',
        message: 'Keine Berechtigung fÃ¼r diese Aktion'
      });
    }
    // Rest der Handler-Logik...
  }
}
```

#### 3. Frontend Permission-Guards (PFLICHT):
```typescript
import { useUserPermissions } from '../../../hooks/useUserPermissions';

const [Page]Page: React.FC = () => {
  const { hasPageAccess, hasPageAction } = useUserPermissions();
  
  if (!hasPageAccess('[module]', '[page]')) {
    return (
      <div className="error-state">
        <h2>ğŸš« Zugriff verweigert</h2>
        <p>Sie haben keine Berechtigung fÃ¼r diese Seite.</p>
      </div>
    );
  }
  
  return (
    <div className="[module]-page">
      {hasPageAction('[module]', '[page]', 'create') && (
        <button className="btn btn-primary">Neu erstellen</button>
      )}
    </div>
  );
};
```

### User/Permission Integration Checkliste:

#### Backend (PFLICHT):
1. âœ… Module-Definition in `hierarchyAnalyzer.ts` hinzufÃ¼gen  
2. âœ… Permission-Checks in alle `orchestrator.ts` Handler einbauen  
3. âœ… Tests fÃ¼r Permission-Scenarios schreiben

#### Frontend (PFLICHT):
1. âœ… `useUserPermissions` Hook in alle Pages integrieren  
2. âœ… Permission-Guards fÃ¼r Page-Access implementieren  
3. âœ… Feature-Guards fÃ¼r Actions implementieren  
4. âœ… Error-States fÃ¼r Permission-Denied-Scenarios

### NICHT ERLAUBT (User/Permissions):
âŒ Neue Module ohne Permission-System-Integration  
âŒ Frontend-Pages ohne Permission-Guards  
âŒ Backend-APIs ohne hierarchische Permission-Checks  
âŒ Module-Definitionen nicht in `hierarchyAnalyzer.ts` hinzugefÃ¼gt  
âŒ Features ohne Action-Level-Permission-Checks  
âŒ Permission-System umgehen oder auf alte Auth zurÃ¼ckgreifen

---
## ğŸ—‚ï¸ DATASOURCES & INTEGRATIONS

### DataSources Consumption (KRITISCH)
**FÃ¼r JEDES Modul, das Daten aus `backend/src/datasources/` nutzt:**

#### GrundsÃ¤tze:
- **Lesen**: Kombinierte Quelle (entra + manual) via `entraac/combined.ts`
- **Schreiben**: AusschlieÃŸlich in manuelle Quelle (`manual`). `entra` ist read-only
- **Import**: `import { getCombinedUsers, findCombinedUsers, createManualUser } from '../../datasources';`

#### Mapping-Standard:
- `displayName` â†’ `firstName`/`lastName`
- `mail`/`userPrincipalName` â†’ `email`
- `jobTitle` â†’ `position`
- `department` â†’ `department`

#### NICHT ERLAUBT:
âŒ Direkte externe API-Calls (Graph) aus Modulen  
âŒ Schreiben in `entra`  
âŒ Umgehen der zentralen DataSources-Re-Exports

### AI/RAG Integration Rules
**Bei `backend/src/modules/ai/**` Ã„nderungen:**
- âœ… `docs/modules/ai/API.md` fÃ¼r Endpunkte `/api/ai/chat`, `/api/ai/rag/*` aktualisieren
- âœ… Required ENV: `OPENAI_API_KEY`, `GEMINI_API_KEY`, `OLLAMA_URL`, `RAG_INDEX_PATH`

---

## ğŸ“š DOKUMENTATION & WARTUNG

### Dokumentations-Policy (KRITISCH)
- âœ… Alle `.md`-Dateien MÃœSSEN unter `docs/` liegen
- âœ… Erlaubte Ausnahmen: `README.md` (root), `backend/README.md`, `frontend/README.md`
- âœ… Pfadkonventionen:
  - Global: `docs/CHANGELOG.md`, `docs/INTERDEPENDENCY.md`
  - Module: `docs/modules/[module]/README.md`, `docs/modules/[module]/API.md`
  - Architektur: `docs/architecture/overview.md`

### Automatische Updates (PFLICHT)

#### Bei neuen Modulen:
1. âœ… `docs/modules/[module]/README.md` erstellen  
2. âœ… `docs/modules/[module]/API.md` erstellen  
3. âœ… `docs/modules/[module]/CHANGELOG.md` erstellen  
4. âœ… `docs/DOCUMENTATION_OVERVIEW.md` aktualisieren  
5. âœ… `docs/INTERDEPENDENCY.md` um Dependencies erweitern  
6. âœ… `docs/CHANGELOG.md` Version hinzufÃ¼gen

#### Bei DataSources/Integrations (KRITISCH):
1. âœ… `docs/INTERDEPENDENCY.md` - DataSources-Dependencies erweitern  
2. âœ… `docs/INTERDEPENDENCY.md` - Environment-Variables dokumentieren  
3. âœ… `docs/INTERDEPENDENCY.md` - External-API-Dependencies hinzufÃ¼gen  
4. âœ… `docs/DOCUMENTATION_OVERVIEW.md` - Integration-Architektur erweitern

#### Bei API-Ã„nderungen:
1. âœ… `docs/modules/[module]/API.md` - Endpunkt-Dokumentation aktualisieren  
2. âœ… `docs/modules/[module]/CHANGELOG.md` - API-Changes dokumentieren

#### Bei Frontend Theme-Ã„nderungen:
1. âœ… `frontend/.env` - Neue `VITE_*` Variablen hinzufÃ¼gen  
2. âœ… `docs/INTERDEPENDENCY.md` - Frontend-Theme-Dependencies erweitern

### Documentation Gates (KRITISCH)
**Jede Ã„nderung in `backend/src/datasources/**` oder `backend/src/modules/**` (APIs/Routes) MUSS folgende Dokumente aktualisieren:**
- `docs/INTERDEPENDENCY.md`
- `docs/DOCUMENTATION_OVERVIEW.md`
- `docs/CHANGELOG.md`
- `docs/modules/[module]/API.md` (bei Endpoint-Ã„nderungen)
- `docs/modules/[module]/README.md` (bei Behavior-Ã„nderungen)

---
## ğŸ§¹ MODUL LIFECYCLE

### Bei JEDEM neuen Modul (Checkliste):
1. âœ… Backend-Ordnerstruktur nach Standard erstellen  
2. âœ… Frontend-Ordnerstruktur nach Standard erstellen  
3. âœ… Backend in `app.ts` registrieren  
4. âœ… Frontend-Route in `App.tsx` registrieren  
5. âœ… Sidebar-Navigation hinzufÃ¼gen  
6. âœ… Dashboard-Kachel erstellen  
7. âœ… Permission-System integrieren  
8. âœ… VollstÃ¤ndige Dokumentation erstellen  
9. âœ… PowerShell-Tests erweitern

### Modul-Entfernung (KRITISCH):
**ALLE AbhÃ¤ngigkeiten MÃœSSEN systematisch entfernt werden:**

#### Backend-Entfernung:
1. âœ… `backend/src/modules/[module]/` - Ordner lÃ¶schen  
2. âœ… `backend/src/app.ts` - Import und Routes entfernen  
3. âœ… `/api/hello` endpoint aktualisieren

#### Frontend-Entfernung:
1. âœ… `frontend/src/modules/[module]/` - Ordner lÃ¶schen  
2. âœ… `frontend/src/App.tsx` - Route entfernen  
3. âœ… `frontend/src/layouts/components/Sidebar.tsx` - Navigation entfernen  
4. âœ… `frontend/src/components/Dashboard.tsx` - Kachel entfernen

#### Dokumentations-Entfernung:
1. âœ… `docs/modules/[module]/` - Ordner lÃ¶schen  
2. âœ… `docs/DOCUMENTATION_OVERVIEW.md` - Referenzen entfernen  
3. âœ… `docs/INTERDEPENDENCY.md` - Dependencies entfernen  
4. âœ… `docs/CHANGELOG.md` - Entfernung dokumentieren

---
## âš™ï¸ TECHNICAL STANDARDS

### Dependency Hygiene
- âœ… Backend: `@types/*` packages in `devDependencies` only
- âœ… Frontend: `react-router-dom` v6.x (nicht v7 ohne Migration)
- âœ… Remove unused packages; add missing ones

### PowerShell KompatibilitÃ¤t  
- âœ… Bevorzuge `;` statt `&&` in npm scripts
- âœ… Erstelle `.ps1` Scripts fÃ¼r Module-spezifische Tasks
- âœ… PowerShell-freundliche Pfade verwenden

### Testing Standards
- âœ… Test-Funktionen in orchestrator fÃ¼r jedes Modul
- âœ… PowerShell-Test-Scripts erstellen  
- âœ… Mock-Daten fÃ¼r Entwicklung bereitstellen

---
**Wichtig**: Diese Regeln gewÃ¤hrleisten Konsistenz, Wartbarkeit und Skalierbarkeit der CompanyAI-Architektur. Alle neuen Module MÃœSSEN das hierarchische Permission-System ab v2.1.0 nutzen.






## Bei JEDEM neuen Modul:
1. âœ… Ordnerstruktur nach Standard erstellen
2. âœ… types.ts mit allen nÃ¶tigen Interfaces
3. âœ… functions/ mit separaten Funktionsdateien  
4. âœ… orchestrator.ts mit Route-Handlern
5. âœ… Integration in index.ts
6. âœ… VollstÃ¤ndige Dokumentation erstellen:
   - docs/modules/[module]/README.md
   - docs/modules/[module]/API.md
   - docs/modules/[module]/CHANGELOG.md
7. âœ… **KRITISCH: Dokumentations-Wartung**
   - docs/DOCUMENTATION_OVERVIEW.md erweitern
   - docs/INTERDEPENDENCY.md um Dependencies erweitern
   - docs/README.md Module-Liste aktualisieren
   - docs/CHANGELOG.md Version hinzufÃ¼gen
8. âœ… Test-Script erweitern
9. âœ… Haupt-Dokumentation aktualisieren

## Bei JEDER neuen DataSource/Integration:
1. âœ… Ordnerstruktur in `backend/src/datasources/[source]/` erstellen
2. âœ… Types, Store, Client/Sync-Logik implementieren
3. âœ… API-Routes in `backend/src/app.ts` registrieren
4. âœ… .env Variablen hinzufÃ¼gen und dokumentieren
5. âœ… **KRITISCH: INTERDEPENDENCY.md aktualisieren**
   - DataSources-Dependencies-Sektion erweitern
   - Environment-Variables (.env) dokumentieren
   - External-API-Dependencies hinzufÃ¼gen
   - Frontend-API-Bindings dokumentieren
   - Cross-DataSource Dependencies dokumentieren
6. âœ… `docs/DOCUMENTATION_OVERVIEW.md` erweitern
7. âœ… `docs/CHANGELOG.md` aktualisieren
8. âœ… Frontend-Integration planen und dokumentieren

## Neue Module â€“ Verbindliche Backend-/Frontend-Integration (KRITISCH)

### Backend (Pflicht)
- Ordner: `backend/src/modules/[module]/` mit Struktur gemÃ¤ÃŸ Modulstandards (siehe oben)
- Routen-Registrierung: `register[Module]Routes(apiRouter)` in `backend/src/app.ts` hinzufÃ¼gen
- Auth: `requireAuth`/`requirePermission` konsequent verwenden
- Health/Hello: Endpunkt-Liste in `/api/hello` um Modul ergÃ¤nzen (Beschreibung + Endpunkte)
- Tests: Mindestens Health-/Routing-Test fÃ¼r neues Modul

### Frontend (Pflicht)
- Ordner: `frontend/src/modules/[module]/` mit:
  - `[Module]Module.tsx` (interner Router gemÃ¤ÃŸ Standard)
  - `pages/` (mind. eine Page-Komponente)
  - `styles/[Module]Pages.css`
- Router: In `frontend/src/App.tsx` Route fÃ¼r das Modul registrieren:
  - `<Route path="/[module]/*" element={<MainLayout><[Module]Module /></MainLayout>} />` (mit `RequireAuth` Wrapper)
- Navigation (Pflicht): In `frontend/src/layouts/components/Sidebar.tsx` Navigations-Eintrag hinzufÃ¼gen (inkl. Submenu, falls zutreffend)
- UI-Standards: Vorhandene CSS-Klassen verwenden (page-header, content-section, etc.)

### Page-Struktur je Modul (Pflicht)
- FÃ¼r JEDES fachliche Feature im Modul MUSS eine eigene Page-Komponente angelegt werden:
  - `frontend/src/modules/[module]/pages/[Feature]Page.tsx`
  - Beispiele: `EmployeesPage.tsx`, `OnboardingPage.tsx`, `ReportsPage.tsx`, `StatsPage.tsx`
- Der Modul-Router MUSS alle Feature-Pages per Route erreichbar machen:
  - `/[module]/[feature]` â†’ rendert die korrekte `[Feature]Page`
- Die Sidebar MUSS ein Submenu mit EintrÃ¤gen fÃ¼r alle Feature-Pages enthalten
- Jede neue Page MUSS Loading-, Error- und Empty-States gemÃ¤ÃŸ Standard implementieren und die Auth-Header bei API-Calls verwenden

### Dashboard-Integration (Pflicht)
- `frontend/src/components/Dashboard.tsx` um eine Modul-Kachel/-Sektion erweitern:
  - Titel: Modulname (Icon optional)
  - Kurzbeschreibung (1â€“2 SÃ¤tze)
  - Link/Action: Button zur Modul-Startseite (`/[module]`)
  - Optional: einfache Kennzahlen (falls verfÃ¼gbar)
- Kachel-Layout, Klassen und Stil gemÃ¤ÃŸ bestehenden Dashboard-Karten verwenden.

### Dokumentation & Scripte (Pflicht)
- `docs/modules/[module]/` erstellen (README.md, API.md, CHANGELOG.md)
- `docs/DOCUMENTATION_OVERVIEW.md` und `docs/INTERDEPENDENCY.md` um neues Modul und AbhÃ¤ngigkeiten ergÃ¤nzen
- PowerShell-Skripte anpassen (Tests/Checks), falls relevant

Hinweis: Module ohne vollstÃ¤ndige Backend-Registrierung, Frontend-Router-Integration und Sidebar-Navigation werden nicht angenommen. FÃ¼r jedes neue Modul mÃ¼ssen die Routen in `App.tsx` registriert und passende NavigationseintrÃ¤ge in `Sidebar.tsx` ergÃ¤nzt werden.

ZusÃ¤tzlich ist die Dashboard-Integration Pflicht: FÃ¼r jedes neue Modul muss eine Kachel im Dashboard vorhanden sein, die zur Route `/[module]` fÃ¼hrt und das Modul kurz beschreibt.

## Frontend-Standards (React + TypeScript)

### Frontend-Modulstruktur - Befolge IMMER:
```
frontend/src/
â”œâ”€â”€ layouts/                    # Layout-Komponenten (wiederverwendbar)
â”‚   â”œâ”€â”€ MainLayout.tsx         # Haupt-Layout mit Header + Sidebar
â”‚   â”œâ”€â”€ AuthLayout.tsx         # Login/Auth-Layout
â”‚   â””â”€â”€ components/
â”‚       â”œâ”€â”€ Header.tsx         # Globaler Header
â”‚       â””â”€â”€ Sidebar.tsx        # Navigation-Sidebar
â”œâ”€â”€ modules/                   # Modulbasierte Komponenten
â”‚   â”œâ”€â”€ [module]/
â”‚   â”‚   â”œâ”€â”€ [Module]Module.tsx # Haupt-Modul mit Router
â”‚   â”‚   â”œâ”€â”€ pages/            # Seiten-Komponenten
â”‚   â”‚   â”‚   â”œâ”€â”€ [Page]Page.tsx
â”‚   â”‚   â”‚   â””â”€â”€ [Page]Page.tsx
â”‚   â”‚   â””â”€â”€ styles/
â”‚   â”‚       â””â”€â”€ [Module]Pages.css
â”‚   â””â”€â”€ auth/
â”‚       â””â”€â”€ LoginPage.tsx
â”œâ”€â”€ components/                # Globale UI-Komponenten
â”‚   â”œâ”€â”€ Dashboard.tsx
â”‚   â””â”€â”€ [Component].tsx
â””â”€â”€ App.tsx                   # Router-Konfiguration
```

### Frontend-Datei-Standards:

#### 1. Modul-Router-Pattern:
```typescript
// [Module]Module.tsx - IMMER diese Struktur
import React from 'react';
import { Routes, Route, Navigate } from 'react-router-dom';
import [Page]Page from './pages/[Page]Page';

const [Module]Module: React.FC = () => {
  return (
    <div className="[module]-module">
      <Routes>
        <Route path="/" element={<Navigate to="/[module]/[default]" replace />} />
        <Route path="/[page]" element={<[Page]Page />} />
        <Route path="*" element={<Navigate to="/[module]/[default]" replace />} />
      </Routes>
    </div>
  );
};

export default [Module]Module;
```

#### 2. Page-Komponenten-Pattern:
```typescript
// pages/[Page]Page.tsx - IMMER diese Struktur
import React, { useState, useEffect } from 'react';
import '../styles/[Module]Pages.css';

interface [Entity] {
  id: string;
  // weitere Properties
}

const [Page]Page: React.FC = () => {
  const [data, setData] = useState<[Entity][]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    loadData();
  }, []);

  const loadData = async () => {
    try {
      setLoading(true);
      setError(null);

      const token = localStorage.getItem('authToken');
      const response = await fetch('http://localhost:5000/api/[module]/[endpoint]', {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });

      const result = await response.json();
      if (result.success && result.data) {
        setData(result.data.data || result.data);
      } else {
        setError(result.message || 'Fehler beim Laden');
      }
    } catch (err) {
      setError('Verbindungsfehler zum Backend');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="[module]-page">
      <div className="page-header">
        <div className="page-title">
          <h1>[Icon] [Title]</h1>
          <p>[Description]</p>
        </div>
        <div className="page-actions">
          <button className="btn btn-primary">
            [Action]
          </button>
        </div>
      </div>

      <div className="content-section">
        {/* Content hier */}
      </div>
    </div>
  );
};

export default [Page]Page;
```

#### 3. CSS-Standards - Folge IMMER diesen Klassen:
```css
/* Basis-Layout-Klassen */
.[module]-page          # Haupt-Container
.page-header           # Header mit Titel und Actions
.page-title            # Titel-Bereich
.page-actions          # Button-Bereich
.content-section       # Haupt-Inhalt
.filters-section       # Filter-Bereich
.page-summary          # Zusammenfassung unten

/* Button-Klassen */
.btn                   # Basis-Button
.btn-primary           # Haupt-Action (blau)
.btn-secondary         # SekundÃ¤r-Action (grau)
.btn-success           # Erfolg-Action (grÃ¼n)
.btn-small             # Kleine Buttons
.btn-outline           # Umrandete Buttons

/* Status-Klassen */
.loading-state         # Loading-Zustand
.error-state           # Fehler-Zustand
.empty-state           # Leerer Zustand

/* Layout-Modi */
.main-layout.fullwidth # Vollbild-Layout
.main-layout.compact   # Kompaktes Layout
```

### API-Integration-Standards:

#### 1. Authentifizierung - IMMER verwenden:
```typescript
const token = localStorage.getItem('authToken');
const headers = {
  'Authorization': `Bearer ${token}`,
  'Content-Type': 'application/json'
};
```

#### 2. Error-Handling - IMMER implementieren:
```typescript
try {
  // API-Call
} catch (err) {
  setError('Verbindungsfehler zum Backend');
  console.error('Fehler beim [Action]:', err);
}
```

#### 3. Loading-States - IMMER verwenden:
```typescript
const [loading, setLoading] = useState(true);

// In JSX:
{loading && (
  <div className="loading-state">
    <div className="loading-spinner"></div>
    <p>Lade [Data]...</p>
  </div>
)}
```

### Router-Integration-Standards:

#### 1. App.tsx - Router-Struktur:
```typescript
// IMMER diese Router-Struktur befolgen
<Router>
  <Routes>
    <Route path="/login" element={
      <AuthLayout><LoginPage /></AuthLayout>
    } />
    <Route path="/[module]/*" element={
      <MainLayout><[Module]Module /></MainLayout>
    } />
    <Route path="*" element={<Navigate to="/" replace />} />
  </Routes>
</Router>
```

#### 2. Layout-Integration - Module nutzen Layouts automatisch:
```typescript
// Layout wird durch Router bereitgestellt, nicht direkt importiert
// Module erhalten Layout-Context automatisch
```

### State-Management-Standards:

#### 1. Lokaler State fÃ¼r Seiten-Daten:
```typescript
const [data, setData] = useState<Type[]>([]);
const [loading, setLoading] = useState(true);
const [error, setError] = useState<string | null>(null);
const [filters, setFilters] = useState({ /* filter object */ });
```

#### 2. localStorage fÃ¼r User-Daten:
```typescript
// Authentifizierung
localStorage.getItem('authToken')
localStorage.getItem('userRole')
localStorage.getItem('userName')
```

### Naming-Conventions Frontend:

#### Komponenten:
- PascalCase: `EmployeesPage.tsx`, `HeaderComponent.tsx`
- Seiten enden mit `Page`: `EmployeesPage`, `DashboardPage`
- Module enden mit `Module`: `HRModule`, `SupportModule`

#### CSS-Klassen:
- kebab-case: `.employee-card`, `.ticket-list`
- Modul-PrÃ¤fix: `.hr-page`, `.support-module`
- Status-PrÃ¤fix: `.status-active`, `.priority-high`

#### Dateien:
- Komponenten: PascalCase.tsx
- Styles: PascalCase.css oder kebab-case.css
- Module-Ordner: lowercase mit Bindestrich

## Frontend-Integration-Checkliste:

### Bei JEDEM neuen Frontend-Modul:
1. âœ… Modul-Ordner in `src/modules/[module]/` erstellen
2. âœ… `[Module]Module.tsx` mit Router-Setup
3. âœ… `pages/` Ordner mit mindestens einer Seite
4. âœ… `styles/[Module]Pages.css` fÃ¼r Modul-Styles
5. âœ… Integration in `App.tsx` Router
6. âœ… Navigation in `Sidebar.tsx` hinzufÃ¼gen
7. âœ… API-Integration mit Backend-Endpunkten
8. âœ… Error-Handling und Loading-States
9. âœ… Responsive Design testen
10. âœ… **KRITISCH: Dokumentations-Wartung**
    - docs/DOCUMENTATION_OVERVIEW.md um Frontend-Inhalte erweitern
    - docs/INTERDEPENDENCY.md um Frontend-Dependencies erweitern
    - docs/modules/[module]/README.md um Frontend-Sektion erweitern
    - docs/README.md Frontend-Features aktualisieren

## Frontend NICHT ERLAUBT:
âŒ Direkte Layout-Imports in Modulen
âŒ Inline-Styles statt CSS-Klassen
âŒ API-Calls ohne Error-Handling
âŒ Fehlende Loading-States
âŒ Untypisierte Komponenten-Props
âŒ Fehlende Responsive-Design
âŒ Module ohne Router-Integration
âŒ Authentifizierung umgehen
âŒ Frontend-Module ohne Dokumentations-Updates
âŒ Neue Pages ohne INTERDEPENDENCY.md Dependencies-Update
âŒ CSS-Ã„nderungen ohne Shared-Component-Dokumentation

## Modul-Entfernung und LÃ¶schung (KRITISCH)

Wenn ein Modul entfernt oder gelÃ¶scht werden soll, MÃœSSEN ALLE AbhÃ¤ngigkeiten systematisch entfernt werden:

### Backend-Entfernung (Pflicht):
```bash
1. âœ… backend/src/modules/[module]/ - Kompletten Ordner lÃ¶schen
2. âœ… backend/src/app.ts - Import und register[Module]Routes() entfernen
3. âœ… backend/src/app.ts - Modul aus /api/health und /api/hello Endpunkten entfernen
4. âœ… Alle Tests die das Modul referenzieren lÃ¶schen/anpassen
5. âœ… Package.json Dependencies prÃ¼fen (falls modul-spezifische Packages)
```

### Frontend-Entfernung (Pflicht):
```bash
1. âœ… frontend/src/modules/[module]/ - Kompletten Ordner lÃ¶schen
2. âœ… frontend/src/App.tsx - Route "/[module]/*" komplett entfernen
3. âœ… frontend/src/layouts/components/Sidebar.tsx - Navigation-Eintrag entfernen
4. âœ… frontend/src/components/Dashboard.tsx - Modul-Kachel entfernen
5. âœ… Alle Imports/Referenzen auf das Modul in anderen Komponenten entfernen
6. âœ… CSS-Klassen prÃ¼fen die modul-spezifisch waren (falls global verwendet)
```

### Dokumentations-Entfernung (KRITISCH):
```bash
1. âœ… docs/modules/[module]/ - Kompletten Ordner lÃ¶schen
2. âœ… docs/DOCUMENTATION_OVERVIEW.md - Modul-Referenzen entfernen
3. âœ… docs/INTERDEPENDENCY.md - Alle Dependencies zum Modul entfernen
4. âœ… docs/README.md - Modul aus Listen und Metriken entfernen
5. âœ… docs/CHANGELOG.md - Eintrag Ã¼ber Modul-Entfernung hinzufÃ¼gen:
   ```markdown
   ## [Version] - [Datum]
   ### Entfernt
   - **[Module] Modul komplett entfernt**
     - Backend: Ordner, Routen, Tests
     - Frontend: Komponenten, Router, Navigation, Dashboard-Kachel
     - Dokumentation: Modul-Docs, Dependencies, Referenzen
     - Grund: [BegrÃ¼ndung fÃ¼r Entfernung]
   ```
```

### VollstÃ¤ndigkeits-Check nach Modul-Entfernung:
```bash
âœ… Keine Backend-Imports/Routes mehr vorhanden?
âœ… Keine Frontend-Components/Routes mehr vorhanden?
âœ… Alle Navigation-Links entfernt?
âœ… Dashboard ohne Modul-Kachel?
âœ… Dokumentation komplett bereinigt?
âœ… CHANGELOG.md dokumentiert Entfernung?
âœ… Keine broken Links in verbleibender Dokumentation?
âœ… Tests laufen noch durch?
âœ… Frontend startet ohne Fehler?
âœ… Backend startet ohne Fehler?
```

### Entfernungs-Reihenfolge (Empfohlen):
```bash
1. ğŸ”´ CHANGELOG.md - Entfernung dokumentieren (mit BegrÃ¼ndung)
2. ğŸ”„ Frontend - Routen, Navigation, Dashboard bereinigen
3. ğŸ”„ Backend - Ordner, Imports, Routen entfernen
4. ğŸ“š Dokumentation - Referenzen und Dependencies bereinigen
5. âœ… Tests - VollstÃ¤ndigkeits-Check durchfÃ¼hren
```

### NICHT ERLAUBT bei Modul-Entfernung:
âŒ Modul-Ordner lÃ¶schen ohne Route-Bereinigung
âŒ Backend/Frontend teilweise entfernt lassen
âŒ Navigation-Links zu gelÃ¶schtem Modul
âŒ Broken Dashboard-Kacheln
âŒ Verwaiste Dokumentations-Referenzen
âŒ Fehlende CHANGELOG.md Dokumentation der Entfernung
âŒ Dependencies in INTERDEPENDENCY.md nicht bereinigt
âŒ Tests die auf gelÃ¶schte Module verweisen

**Wichtig**: Eine Modul-Entfernung ist ein Breaking Change und MUSS ausfÃ¼hrlich in docs/CHANGELOG.md dokumentiert werden, inklusive BegrÃ¼ndung und Auswirkungen auf andere Module.

## Hierarchical Permissions Integration (KRITISCH - NEU v2.1.0)

Bei JEDEM neuen Modul MUSS die Integration in das hierarchische Permission-System berÃ¼cksichtigt werden:

### Modul-Permission-Definition (PFLICHT):
```bash
1. âœ… Modul-SchlÃ¼ssel definieren (z.B. "analytics", "reporting", "inventory")
2. âœ… Page-Definitionen mit Actions erstellen:
   - Page-Keys: beschreibende Namen (z.B. "reports", "dashboards", "export")
   - Actions: view, create, edit, delete, export, import, etc.
   - Limits (optional): dailyQuota, maxRecords, etc.
3. âœ… Modul-spezifische Permission-Logik implementieren
4. âœ… Backend-Permission-Checks in orchestrator.ts-Handlern
5. âœ… Frontend-Permission-Guards fÃ¼r Pages und Features
```

### Backend-Integration mit Permission-System:
```typescript
// orchestrator.ts - IMMER Permission-Checks einbauen
import { AuthenticatedRequest, requirePermission } from '../hr/core/auth';

export class [Module]Orchestrator {
  static async handle[Action](req: AuthenticatedRequest, res: Response) {
    // Permission-Check fÃ¼r hierarchisches System
    const hasPermission = await checkHierarchicalPermission(
      req.user.id, 
      '[module]', 
      '[page]', 
      '[action]'
    );
    
    if (!hasPermission) {
      return res.status(403).json({
        success: false,
        error: 'PermissionDenied',
        message: 'Keine Berechtigung fÃ¼r diese Aktion'
      });
    }
    
    // Rest der Handler-Logik...
  }
}
```

### Frontend-Permission-Guards:
```typescript
// pages/[Page]Page.tsx - Permission-Guards implementieren
import { useUserPermissions } from '../../../hooks/useUserPermissions';

const [Page]Page: React.FC = () => {
  const { hasPageAccess, hasPageAction } = useUserPermissions();
  
  // Page-Level Guard
  if (!hasPageAccess('[module]', '[page]')) {
    return (
      <div className="error-state">
        <h2>ğŸš« Zugriff verweigert</h2>
        <p>Sie haben keine Berechtigung fÃ¼r diese Seite.</p>
      </div>
    );
  }
  
  // Feature-Level Guards im JSX
  return (
    <div className="[module]-page">
      {/* Conditional Features basierend auf Permissions */}
      {hasPageAction('[module]', '[page]', 'create') && (
        <button className="btn btn-primary">Neu erstellen</button>
      )}
      {hasPageAction('[module]', '[page]', 'export') && (
        <button className="btn btn-secondary">Exportieren</button>
      )}
    </div>
  );
};
```

### hierarchyAnalyzer.ts erweitern (Backend):
```typescript
// Neue Module mÃ¼ssen in die Modul-Definitionen eingepflegt werden
export const MODULE_DEFINITIONS = [
  {
    key: "hr",
    name: "HR", 
    icon: "ğŸ‘¥",
    pages: [...]
  },
  {
    key: "[new-module]",
    name: "[Module Display Name]",
    icon: "[Icon]",
    pages: [
      {
        key: "[page1]",
        name: "[Page Display Name]",
        icon: "[Page Icon]",
        actions: [
          { key: "view", name: "Anzeigen", description: "..." },
          { key: "create", name: "Erstellen", description: "..." },
          { key: "edit", name: "Bearbeiten", description: "..." },
          { key: "delete", name: "LÃ¶schen", description: "..." }
        ],
        limits: [ // Optional
          { key: "dailyQuota", name: "TÃ¤gliche Anfragen", type: "number", defaultValue: 100 }
        ]
      }
    ]
  }
];
```

### Permission-System-Integration-Checkliste (PFLICHT):

#### Bei JEDEM neuen Backend-Modul:
```bash
1. âœ… Module-Definition in hierarchyAnalyzer.ts hinzufÃ¼gen (Modul + Pages + Actions)
2. âœ… Permission-Checks in alle orchestrator.ts Handler einbauen
3. âœ… Modul-spezifische Permission-Logic implementieren (falls nÃ¶tig)
4. âœ… API-Endpunkte fÃ¼r Permission-Management erweitern (falls nÃ¶tig)
5. âœ… Tests fÃ¼r Permission-Scenarios schreiben
```

#### Bei JEDEM neuen Frontend-Modul:
```bash
1. âœ… useUserPermissions Hook in alle Pages integrieren
2. âœ… Permission-Guards fÃ¼r Page-Access implementieren
3. âœ… Feature-Guards fÃ¼r Actions implementieren (Create/Edit/Delete buttons)
4. âœ… Conditional UI basierend auf User-Permissions
5. âœ… Error-States fÃ¼r Permission-Denied-Scenarios
6. âœ… Loading-States wÃ¤hrend Permission-Checks
```

#### Dokumentations-Updates (KRITISCH):
```bash
1. âœ… docs/modules/[module]/README.md - Permission-Sektion hinzufÃ¼gen:
   - Welche Permissions das Modul nutzt
   - Hierarchische Integration (Department/SubGroup/Individual)
   - Permission-Dependencies zu anderen Modulen
2. âœ… docs/modules/[module]/API.md - Permission-Requirements dokumentieren:
   - Welche Permission fÃ¼r welchen Endpoint erforderlich
   - Hierarchische Permission-Checks beschreiben
   - Error-Responses bei Permission-Denied
3. âœ… docs/INTERDEPENDENCY.md - Permission-Dependencies ergÃ¤nzen:
   - Modul-spezifische Permission-Integration
   - Cross-Module-Permission-Dependencies
   - Hierarchical Permission System Integration
4. âœ… docs/DOCUMENTATION_OVERVIEW.md - Permission-Dokumentation erweitern
5. âœ… docs/CHANGELOG.md - Neue Permission-Integration dokumentieren
```

### NICHT ERLAUBT (Hard-Fails):
âŒ Neue Module ohne Permission-System-Integration
âŒ Frontend-Pages ohne Permission-Guards  
âŒ Backend-APIs ohne hierarchische Permission-Checks
âŒ Module-Definitionen nicht in hierarchyAnalyzer.ts hinzugefÃ¼gt
âŒ Permission-Integration ohne Dokumentations-Update
âŒ Features ohne Action-Level-Permission-Checks
âŒ Permission-System umgehen oder direkt auf alte Auth zurÃ¼ckgreifen
âŒ Neue Module ohne Permission-Test-Scenarios

### Beispiel-Integration neues "Analytics"-Modul:

#### 1. Backend hierarchyAnalyzer.ts erweitern:
```typescript
{
  key: "analytics",
  name: "Analytics", 
  icon: "ğŸ“Š",
  pages: [
    {
      key: "reports",
      name: "Berichte",
      icon: "ğŸ“ˆ",
      actions: [
        { key: "view", name: "Anzeigen", description: "Berichte anzeigen" },
        { key: "create", name: "Erstellen", description: "Neue Berichte erstellen" },
        { key: "export", name: "Exportieren", description: "Berichte exportieren" },
        { key: "delete", name: "LÃ¶schen", description: "Berichte lÃ¶schen" }
      ],
      limits: [
        { key: "monthlyReports", name: "Berichte pro Monat", type: "number", defaultValue: 10 }
      ]
    }
  ]
}
```

#### 2. Backend orchestrator.ts mit Permission-Checks:
```typescript
static async handleGetReports(req: AuthenticatedRequest, res: Response) {
  const hasPermission = await checkHierarchicalPermission(
    req.user.id, 'analytics', 'reports', 'view'
  );
  
  if (!hasPermission) {
    return res.status(403).json({
      success: false,
      error: 'PermissionDenied',
      message: 'Keine Berechtigung um Analytics-Berichte zu sehen'
    });
  }
  
  // Rest der Logic...
}
```

#### 3. Frontend Permission-Guards:
```typescript
const ReportsPage: React.FC = () => {
  const { hasPageAccess, hasPageAction } = useUserPermissions();
  
  if (!hasPageAccess('analytics', 'reports')) {
    return <PermissionDenied />;
  }
  
  return (
    <div className="analytics-page">
      <div className="page-actions">
        {hasPageAction('analytics', 'reports', 'create') && (
          <button>Neuen Bericht erstellen</button>
        )}
        {hasPageAction('analytics', 'reports', 'export') && (
          <button>Exportieren</button>
        )}
      </div>
    </div>
  );
};
```

### Migration bestehender Module:

Bestehende Module MÃœSSEN schrittweise in das hierarchische Permission-System integriert werden:

```bash
1. âœ… Modul-Definition hinzufÃ¼gen (hierarchyAnalyzer.ts)
2. âœ… Permission-Checks schrittweise in Backend einbauen
3. âœ… Frontend-Guards schrittweise hinzufÃ¼gen  
4. âœ… Dokumentation aktualisieren
5. âœ… Tests erweitern
6. âœ… Migration in CHANGELOG.md dokumentieren
```

**Wichtig**: Das hierarchische Permission-System ist ab v2.1.0 der neue Standard. Alle neuen Module MÃœSSEN dieses System von Anfang an nutzen. Bestehende Module mÃ¼ssen sukzessive migriert werden.

Diese Regeln gewÃ¤hrleisten Konsistenz, Wartbarkeit und Skalierbarkeit der CompanyAI-Architektur.

---

## ğŸ”„ INTELLIGENTE RULE-EVOLUTION & STRUKTURSCHUTZ

### ğŸ“ PROJEKTSTRUKTUR-SCHUTZ (KRITISCH)

#### Bestehende CompanyAI-Struktur MUSS beibehalten werden:
```
CompanyAI/
â”œâ”€â”€ backend/src/
â”‚   â”œâ”€â”€ modules/               # âœ… Modulare Architektur beibehalten
â”‚   â”‚   â”œâ”€â”€ [module]/
â”‚   â”‚   â”‚   â”œâ”€â”€ orchestrator.ts    # âœ… PFLICHT fÃ¼r API-Handler
â”‚   â”‚   â”‚   â”œâ”€â”€ types.ts           # âœ… PFLICHT fÃ¼r Interfaces  
â”‚   â”‚   â”‚   â”œâ”€â”€ core/              # âœ… Business Logic
â”‚   â”‚   â”‚   â”œâ”€â”€ functions/         # âœ… Spezifische Funktionen
â”‚   â”‚   â”‚   â””â”€â”€ README.md         # âœ… Dokumentation
â”‚   â”œâ”€â”€ services/             # âœ… Shared Services (auth.service.ts etc.)
â”‚   â”œâ”€â”€ datasources/          # âœ… Datenquellen (entraac, ldap etc.)
â”‚   â””â”€â”€ utils/               # âœ… Utilities
â”œâ”€â”€ frontend/src/
â”‚   â”œâ”€â”€ modules/             # âœ… Frontend-Module spiegeln Backend
â”‚   â”‚   â”œâ”€â”€ [module]/
â”‚   â”‚   â”‚   â”œâ”€â”€ pages/           # âœ… React-Komponenten
â”‚   â”‚   â”‚   â”œâ”€â”€ components/      # âœ… Wiederverwendbare Komponenten  
â”‚   â”‚   â”‚   â””â”€â”€ [Module].tsx     # âœ… Haupt-Modul-Komponente
â”‚   â”œâ”€â”€ context/             # âœ… React Contexts (PermissionContext etc.)
â”‚   â”œâ”€â”€ layouts/             # âœ… Layout-Komponenten
â”‚   â””â”€â”€ components/          # âœ… Globale Komponenten
â””â”€â”€ admin-data/              # âœ… JSON-basierte Datenspeicherung
    â”œâ”€â”€ department-permissions.json
    â””â”€â”€ databases/
```

### ğŸš¨ VERBOTEN: Struktur-Breaking Changes
- âŒ Neue Top-Level-Ordner ohne Genehmigung
- âŒ Orchestrator-Pattern umgehen (`orchestrator.ts` ist Pflicht)
- âŒ Module auÃŸerhalb von `modules/` erstellen
- âŒ Direct Database-Zugriff (nur Ã¼ber Services)
- âŒ Hardcoded Paths Ã¤ndern

---

## ğŸ¤” RULE-EXCEPTION & EVOLUTION-SYSTEM

### Wenn du eine SINNVOLLE Ã„nderung machst, die gegen Rules verstÃ¶ÃŸt:

#### SCHRITT 1: Exception-Request erstellen
```markdown
<!-- RULE-EXCEPTION-REQUEST -->
## ğŸ“‹ Rule-VerstoÃŸ-BegrÃ¼ndung

**VerstoÃŸene Rule:** [Welche Rule wird verletzt?]
**Grund:** [Warum ist diese Ã„nderung sinnvoll?]
**Auswirkungen:** [Was Ã¤ndert sich?]
**Vorteile:** [Welche Verbesserungen bringt das?]
**RÃ¼ckwÃ¤rts-KompatibilitÃ¤t:** [Bleibt alles funktional?]

### Beispiel:
**VerstoÃŸene Rule:** "Keine neuen Top-Level-Ordner"
**Grund:** "Neuer 'integrations/' Ordner fÃ¼r externe API-Verbindungen"
**Auswirkungen:** "Bessere Trennung von Core-Logik und Integrationen"
**Vorteile:** "Klarere Architektur, einfachere Wartung"
**RÃ¼ckwÃ¤rts-KompatibilitÃ¤t:** "Ja, bestehende Module unverÃ¤ndert"
```

#### SCHRITT 2: Frage um Genehmigung
```
ğŸ¤” RULE-EXCEPTION-REQUEST: Darf ich [BESCHREIBUNG] machen?
Grund: [KURZE BEGRÃœNDUNG]
```

#### SCHRITT 3: Bei Genehmigung â†’ Rule-Update
Nach Genehmigung MUSS diese Rule aktualisiert werden mit:
```markdown
### âœ… NEUE REGEL (Akzeptierte Exception vom DD.MM.YYYY)
- [Beschreibung der neuen erlaubten Praxis]
- [BegrÃ¼ndung warum es jetzt erlaubt ist]
```

---

## ğŸ” KONSISTENZ-CHECKS & QUALITÃ„TSSICHERUNG

### Backend-Modul VollstÃ¤ndigkeits-Check:
```bash
# Jedes neue Backend-Modul MUSS haben:
backend/src/modules/[module]/
â”œâ”€â”€ orchestrator.ts     # âœ… API-Handler
â”œâ”€â”€ types.ts           # âœ… TypeScript Interfaces
â”œâ”€â”€ core/              # âœ… Business Logic
â””â”€â”€ README.md          # âœ… Dokumentation
```

### Frontend-Modul VollstÃ¤ndigkeits-Check:
```bash
# Jedes neue Frontend-Modul MUSS haben:
frontend/src/modules/[module]/
â”œâ”€â”€ [Module].tsx       # âœ… Haupt-Komponente
â”œâ”€â”€ pages/             # âœ… Route-Komponenten
â””â”€â”€ components/        # âœ… Wiederverwendbare Komponenten
```

### API-Consistency Check:
```typescript
// Alle API-Responses MÃœSSEN diese Struktur haben:
{
  success: boolean,
  data?: any,
  error?: string,
  message?: string
}
```

### Permission-System Consistency:
```typescript
// Alle geschÃ¼tzten Routes MÃœSSEN:
router.post('/api/[module]/[endpoint]', 
  requireAuth,                    # âœ… Authentication  
  requirePermission('action', 'resource'), # âœ… Authorization
  ModuleOrchestrator.handleMethod # âœ… Handler
);
```

---

## ğŸ›¡ï¸ SECURITY & STABILITY GUARDS

### Kritische Files - Extra Vorsicht:
```
backend/src/services/auth.service.ts      # ğŸ” Authentication Core
backend/src/modules/hr/core/auth.ts       # ğŸ” Authorization Logic  
frontend/src/context/PermissionContext.tsx # ğŸ” Permission Management
backend/admin-data/department-permissions.json # ğŸ“Š Permission Data
frontend/src/App.tsx                      # ğŸ—ï¸ App Architecture
backend/src/app.ts                       # ğŸ—ï¸ Backend Architecture
```

### Vor Ã„nderungen an kritischen Files:
1. **Backup erstellen** (Copy des Files)
2. **Ã„nderungen dokumentieren** (Was, Warum, Auswirkungen)
3. **Testen** nach jeder Ã„nderung
4. **Rollback-Plan** haben

### ğŸš« AUTOMATISCH GENERIERTE DATEIEN - BEARBEITUNG VERBOTEN:
Diese Dateien werden automatisch vom System generiert und dÃ¼rfen NIEMALS manuell bearbeitet werden:
```
backend/admin-data/department-permissions.json  # Auto-Generated durch EISBÃ„R-POPULATION
```

**Warum verboten:**
- Werden bei jedem Server-Neustart automatisch regeneriert
- Manuelle Ã„nderungen gehen verloren
- KÃ¶nnen das Auto-Population-System beschÃ¤digen
- Enthalten automatisch berechnete Berechtigungsstrukturen

**Was stattdessen tun:**
- Ã„nderungen in den Quell-Algorithmen vornehmen (EISBÃ„R-POPULATION System)
- Backend neustart lÃ¤sst Auto-Population laufen
- Berechtigungen Ã¼ber Admin-Portal UI verwalten

---

## ğŸ“ DEVELOPMENT WORKFLOW

### Bei neuen Features:
1. **PrÃ¼fe bestehende Struktur** - Passt es ins Modul-System?
2. **Folge Namenskonventionen** - camelCase, kebab-case etc.
3. **Implementiere Permission-Checks** - Wer darf was?
4. **Dokumentiere Ã„nderungen** - README.md updaten
5. **Teste alle Benutzer-Rollen** - Admin, User, Test-User

### Bei Struktur-Ã„nderungen:
1. **Rule-Exception-Request** stellen
2. **Auf Genehmigung warten**
3. **Bei Genehmigung: Rules updaten**
4. **Ã„nderungen implementieren**
5. **Dokumentation anpassen**

Diese intelligenten Rules schÃ¼tzen die CompanyAI-Architektur und ermÃ¶glichen gleichzeitig sinnvolle Evolution.